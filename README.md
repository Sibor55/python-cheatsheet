Исчерпывающая шпаргалка по Python
===============================
Содержание:
- [[#Контейнеры]]
    - [[#Список]]
    - [[#Словарь]]
    - [[#Множество]]
    - [[#Кортеж]]
    - [[#Range]]
    - [[#Enumerate]]
    - [[#Итератор]]
    - [[#Итераторы из itertools]]
    - [[#Генератор]]
- [[#Типы и классы]]
    - [[#Операции над типами]]
    - [[#Абстрактные базовые классы (ABC)]]
    - [[#Типы чисел]]
    - [[#Строки]]
    - [[#Регулярные выражения]]
    - [[#Форматирование]]
    - [[#Работа с числами в Python]]
    - [[#Комбинаторика]]
    - [[#Работа с датами и временем]]
- [[#Синтаксис]]
    - [[#Аргументы в Python]]
    - [[#Встроенные функции]]
    - [[#Импорт]]
    - [[#Замыкания]]
    - [[#Функция partial]]
    - [[#Non-Local]]
    - [[#Декораторы]]
    - [[#Классы]]
    - [[#Утиная типизация]]
    - [[#Итератор]]
    - [[#Enum]]
    - [[#Исключения]]
- [[#Система]]
    - [[#Exit]]
    - [[#Print]]
    - [[#Pretty Print]]
    - [[#Input]]
    - [[#Command Line Arguments]]
    - [[#Argument Parser]]
    - [[#Открытие файла в Python]]
    - [[#Работа с Путями]]
- [[#Данные]]
    - [[#Работа с JSON]]
    - [[#Работа с Pickle]]
    - [[#Работа с CSV]]
    - [[#SQL]]
    - [[#Bytes]]
    - [[#Struct]]
    - [[#Array]]
    - [[#Memory View]]
    - [[#Deque]]
    - [[#Operator]]
    - [[#Match]]
    - [[#Logging]]
    - [[#Introspection]]
    - [[#Threading]]
    - [[#Coroutines]]
- [[#Библиотеки]]
    - [[#Progress Bar]]
    - [[#Графики]]
    - [[#Table Display]]
    - [[#Консольное приложение]]
    - [[#GUI-Приложение]]
    - [[#Скрейпинг]]
    - [[#Web-приложение]]
    - [[#Профилирование]]
    - [[#NumPy]]
    - [[#Изображения]]
    - [[#Аудио]]
    - [[#Синтезатор]]
    - [[#Pygame]]
    - [[#Pandas]]
    - [[#Plotly]]
- [[#Приложение]]

## `__main__`

Для того чтобы код выполнялся только при запуске файла как основного, а не при его импорте, используется проверка:

```python
if __name__ == '__main__':  # Пропускает следующую строку, если файл был импортирован.
    main()  # Запускает функцию 'def main(): ...'.
```

- **`__name__`** — специальная переменная, которая при запуске файла напрямую будет иметь значение `'__main__'`.
- **`main()`** — функция, которая обычно содержит основную логику программы.
# Контейнеры
## Список

Списки — это изменяемые последовательности в Python. Они могут содержать элементы разных типов и поддерживают индексацию и срезы.

#### Создание списка

```python
<list> = [<el_1>, <el_2>, ...]  # Создание списка. Можно также использовать list(<collection>).
```

#### Индексация и срезы

```python
<el> = <list>[index]           # Индексация. Начинается с 0. Последний индекс -1.
<list> = <list>[<slice>]       # Срез списка: <list>[from_inclusive : to_exclusive : ±шаг].
```

#### Добавление и расширение

```python
<list>.append(<el>)            # Добавляет элемент в конец списка.
<list>.extend(<collection>)    # Расширяет список элементами другой коллекции.
```

#### Сортировка и переворот

```python
<list>.sort()                  # Сортирует элементы списка по возрастанию.
<list>.reverse()               # Переворачивает список на месте.
<list> = sorted(<collection>)  # Возвращает новый отсортированный список.
<iter> = reversed(<list>)      # Возвращает итератор элементов в обратном порядке.
```

#### Сумма и максимальное значение

```python
<el> = max(<collection>)       # Возвращает максимальный элемент в коллекции.
<num> = sum(<collection>)      # Возвращает сумму всех элементов коллекции.
```

#### Примеры с генераторами списков

```python
elementwise_sum  = [sum(pair) for pair in zip(list_a, list_b)]  # Элемент-wise сумма двух списков.
sorted_by_second = sorted(<collection>, key=lambda el: el[1])   # Сортировка по второму элементу.
sorted_by_both   = sorted(<collection>, key=lambda el: (el[1], el[0]))  # Сортировка по двум элементам.
flatter_list     = list(itertools.chain.from_iterable(<list>))   # Разворачивает вложенные списки в один.
```

#### Длина и количество элементов

```python
<int> = len(<list>)            # Возвращает количество элементов в списке.
<int> = <list>.count(<el>)     # Возвращает количество вхождений элемента в список.
<int> = <list>.index(<el>)     # Возвращает индекс первого вхождения элемента или вызывает ValueError.
```

#### Удаление элементов

```python
<el> = <list>.pop()            # Удаляет и возвращает последний элемент.
<list>.pop(index)              # Удаляет и возвращает элемент по индексу.
<list>.insert(<int>, <el>)     # Вставляет элемент в список по указанному индексу.
<list>.remove(<el>)            # Удаляет первое вхождение элемента. Вызывает ValueError, если элемент не найден.
<list>.clear()                 # Очищает список, удаляя все элементы.
```

#### Дополнительная информация

- **`sort()`** сортирует список **на месте**, в отличие от **`sorted()`**, который возвращает новый отсортированный список.
- **`min()`** и **`max()`** работают не только с числами, но и с любыми объектами, которые поддерживают операции сравнения.
- **`itertools.chain.from_iterable()`** позволяет плоско разворачивать вложенные коллекции.

## Словарь

Словарь в Python — это неупорядоченная коллекция, которая хранит пары "ключ-значение".

#### Создание словаря

```python
<dict> = {key_1: val_1, key_2: val_2, ...}  # Создание словаря с парами ключ-значение.
```

#### Доступ к элементам

```python
<value> = <dict>[key]  # Получение значения по ключу. Может вызвать KeyError, если ключ не существует.
<view> = <dict>.keys()  # Возвращает представление ключей.
<view> = <dict>.values()  # Возвращает представление значений.
<view> = <dict>.items()  # Возвращает набор кортежей (ключ, значение).
```

#### Методы для работы с элементами

```python
value = <dict>.get(key, default=None)  # Возвращает значение по ключу, если ключ не найден - возвращает default.
value = <dict>.setdefault(key, default=None)  # Возвращает значение по ключу или записывает default, если ключ отсутствует.
<dict> = collections.defaultdict(<type>)  # Словарь с автоматическим значением по умолчанию для отсутствующих ключей.
<dict> = collections.defaultdict(lambda: 1)  # Словарь с значением по умолчанию 1.
```

#### Создание словаря из других коллекций

```python
<dict> = dict(<collection>)  # Создаёт словарь из коллекции пар (ключ, значение).
<dict> = dict(zip(keys, values))  # Создаёт словарь из двух коллекций (ключи и значения).
<dict> = dict.fromkeys(keys, value=None)  # Создаёт словарь с ключами из коллекции и значениями по умолчанию.
```

#### Обновление и удаление элементов

```python
<dict>.update(<dict>)  # Добавляет элементы из другого словаря. Перезаписывает существующие ключи.
value = <dict>.pop(key)  # Удаляет элемент по ключу и возвращает его значение.
{k for k, v in <dict>.items() if v == value}  # Возвращает ключи, указывающие на указанное значение.
{k: v for k, v in <dict>.items() if k in keys}  # Фильтрует словарь по ключам.
```

### Счётчик

```python
from collections import Counter

counter = Counter(['blue', 'blue', 'blue', 'red', 'red'])
counter['yellow'] += 1  # Увеличиваем количество 'yellow'
print(counter.most_common())  # [('blue', 3), ('red', 2), ('yellow', 1)]
```

**`Counter`** — это подкласс словаря, который удобен для подсчета частоты элементов в коллекции.

## Множество

Множество — это коллекция, которая не содержит повторяющихся элементов и не имеет порядка.

#### Создание множества

```python
<set> = {<el_1>, <el_2>, ...}  # Создаёт множество. Для пустого множества используйте set().
```

#### Методы работы с множествами

```python
<set>.add(<el>)  # Добавляет элемент в множество.
<set>.update(<collection>)  # Добавляет несколько элементов из другой коллекции.
```

#### Операции с множествами

```python
<set> = <set>.union(<coll>)  # Объединение множеств. Эквивалентно <set> | <set>.
<set> = <set>.intersection(<coll>)  # Пересечение множеств. Эквивалентно <set> & <set>.
<set> = <set>.difference(<coll>)  # Разность множеств. Эквивалентно <set> - <set>.
<set> = <set>.symmetric_difference(<coll>)  # Симметрическая разность. Эквивалентно <set> ^ <set>.
<bool> = <set>.issubset(<coll>)  # Проверяет, является ли множество подмножеством другого. Эквивалентно <set> <= <set>.
<bool> = <set>.issuperset(<coll>)  # Проверяет, является ли множество надмножеством другого. Эквивалентно <set> >= <set>.
```

#### Удаление элементов

```python
<el> = <set>.pop()  # Удаляет и возвращает случайный элемент. Вызывает KeyError, если множество пусто.
<set>.remove(<el>)  # Удаляет элемент из множества. Вызывает KeyError, если элемента нет.
<set>.discard(<el>)  # Удаляет элемент из множества, но не вызывает ошибку, если элемента нет.
```

### Замороженное множество

**Замороженные множества** — это неизменяемые множества, которые могут быть использованы как элементы других множеств или в качестве ключей в словарях.

```python
<frozenset> = frozenset(<collection>)  # Создаёт замороженное множество.
```
## Кортеж

**Кортеж** — это неизменяемая коллекция, которая сохраняет порядок элементов и может быть использована как ключ в словарях или элемент в множествах.

#### Создание кортежа

```python
<tuple> = ()  # Пустой кортеж.
<tuple> = (<el>,)  # Кортеж с одним элементом.
<tuple> = (<el_1>, <el_2>, ...)  # Кортеж с несколькими элементами.
```

#### Именованный кортеж

**Именованный кортеж** — это подкласс кортежа, где элементы имеют имена, и к ним можно обращаться как через индексы, так и через имена.

```python
from collections import namedtuple

Point = namedtuple('Point', 'x y')  # Определяем новый тип кортежа с именами x и y.
p = Point(1, y=2)  # Создаем экземпляр кортежа.
print(p)  # Вывод: Point(x=1, y=2)
print(p[0])  # Доступ через индекс: 1
print(p.x)  # Доступ через имя: 1
print(getattr(p, 'y'))  # Доступ через функцию getattr: 2
```

## Range

**Range** — это неизменяемая последовательность целых чисел, часто используемая в циклах.

#### Создание range

```python
<range> = range(stop)  # range(to_exclusive) - последовательность от 0 до stop-1.
<range> = range(start, stop)  # range(from_inclusive, to_exclusive) - последовательность от start до stop-1.
<range> = range(start, stop, ±step)  # range(from_inclusive, to_exclusive, ±step_size) - последовательность с шагом.
```

```python
>>> [i for i in range(3)]
[0, 1, 2]
```

## Enumerate

Функция **enumerate** возвращает пары (индекс, элемент) при итерировании по коллекции.

```python
for i, el in enumerate(<coll>, start=0):  # Возвращает индекс и элемент на каждой итерации.
    print(i, el)
```

## Итератор

**Итератор** — это объект, который позволяет проходить по коллекции по одному элементу за раз.

#### Создание и использование итератора

```python
<iter> = iter(<collection>)  # Получение итератора для коллекции.
<iter> = iter(<function>, to_exclusive)  # Итератор, который вызывает функцию до достижения 'to_exclusive'.
<el> = next(<iter>, default)  # Получение следующего элемента. Возвращает 'default' при завершении.
<list> = list(<iter>)  # Преобразование итератора в список.
```

## Итераторы из itertools

**itertools** — модуль для работы с итераторами, предоставляющий полезные функции для создания и обработки последовательностей.

```python
import itertools as it
```

#### Часто используемые функции из itertools:

```python
<iter> = it.count(start=0, step=1)  # Возвращает бесконечную последовательность, начиная с start и с шагом step.
<iter> = it.repeat(<el>, times)  # Повторяет элемент <el> определенное количество раз или бесконечно.
<iter> = it.cycle(<collection>)  # Бесконечно повторяет элементы коллекции.
```

```python
<iter> = it.chain(<coll>, <coll>, ...)  # Объединяет несколько коллекций в одну последовательность.
<iter> = it.chain.from_iterable(<coll>)  # Преобразует вложенные коллекции в единую последовательность.
```

```python
<iter> = it.islice(<coll>, to_exclusive)  # Возвращает первые 'to_exclusive' элементов.
<iter> = it.islice(<coll>, from_inclusive, to_exclusive)  # Возвращает элементы в пределах от 'from_inclusive' до 'to_exclusive'.
```

Эти функции и структуры данных удобны для работы с последовательностями и позволяют эффективно обрабатывать данные.

## Генератор

**Генератор** — это специальная функция, которая возвращает итератор. Генераторы позволяют лениво вычислять значения по мере их запроса, что делает их эффективными при работе с большими данными.

#### Создание генератора

Генератор создается с использованием оператора `yield`. Каждый вызов `yield` возвращает значение и сохраняет состояние функции, чтобы продолжить выполнение с этого места при следующем вызове.

```python
def count(start, step):
    while True:  # Бесконечный цикл
        yield start  # Возвращает значение и "замораживает" состояние функции
        start += step  # Увеличивает значение на шаг
```

#### Использование генератора

Для использования генератора, необходимо создать его экземпляр и вызывать `next()` для получения следующих значений:

```python
>>> counter = count(10, 2)  # Создаем генератор, начинающий с 10 и увеличивающий на 2
>>> next(counter), next(counter), next(counter)
(10, 12, 14)  # При каждом вызове next() возвращается следующее значение
```

Генераторы полезны для работы с большими последовательностями, когда мы не хотим загружать все элементы в память сразу, а вычисляем их по мере необходимости.

#### Преимущества генераторов:

1. **Память:** Генераторы не хранят все значения в памяти, они вычисляются "на лету".
2. **Производительность:** Генераторы могут быть быстрее, так как они возвращают элементы по одному, без необходимости создавать и хранить целую коллекцию.
3. **Итеративность:** Генераторы могут быть использованы как итераторы в любых конструкциях, поддерживающих итерацию, таких как циклы `for`.

Таким образом, генераторы — это эффективный инструмент для работы с большими или бесконечными последовательностями.

# Типы и классы

В Python все объекты являются экземплярами классов (или типов), и для каждого объекта можно получить его тип с помощью функции `type()`.
## Операции над типами
#### Получение типа объекта

Каждый объект в Python имеет тип, который можно получить с помощью функции `type()`:

```python
<type> = type(<el>)  # Возвращает тип объекта.
```

Также можно использовать атрибут `__class__`, который является синонимом `type()`:

```python
>>> type('a'), 'a'.__class__, str
(<class 'str'>, <class 'str'>, <class 'str'>)
```

#### Проверка типа

Для проверки, является ли объект экземпляром конкретного типа, используется функция `isinstance()`:

```python
>>> isinstance('a', str)  # Проверка, является ли объект строкой
True
```

Чтобы проверить, является ли тип подклассом другого типа, используется функция `issubclass()`:

```python
>>> issubclass(str, object)  # Проверка, является ли str подклассом object
True
```

## Абстрактные базовые классы (ABC)

Абстрактные базовые классы (ABC) используются для определения интерфейсов, которые должны реализовывать подклассы. Эти классы могут не иметь конкретной реализации, но их подклассы обязаны реализовывать определенные методы.

Пример использования абстрактных базовых классов:

```python
from collections.abc import Iterable, Collection, Sequence

>>> isinstance([1, 2, 3], Iterable)  # Проверка, является ли объект итерируемым
True

>>> isinstance([1, 2, 3], Collection)  # Проверка, является ли объект коллекцией
True
```

#### Основные ABC в Python:

- **Iterable** — объекты, которые можно перебирать (например, списки, строки, диапазоны).
- **Collection** — объекты, которые поддерживают коллекции (например, множества, словари).
- **Sequence** — последовательности, поддерживающие доступ по индексу и другие методы последовательности (например, списки, строки, кортежи).

### Пример работы с числовыми типами

Python предоставляет абстрактные базовые классы для различных типов чисел, такие как `Number`, `Complex`, `Real`, `Rational`, и `Integral`, которые можно использовать для проверки принадлежности объектов к числовым типам:

```python
from numbers import Number, Complex, Real, Rational, Integral

>>> isinstance(123, Number)  # Проверка, является ли объект числом
True
```

## Типы чисел

- **int** — целое число.
- **float** — число с плавающей точкой.
- **complex** — комплексное число.
- **fractions.Fraction** — рациональное число.
- **decimal.Decimal** — число с фиксированной точностью.

Пример таблицы типов чисел:

| Тип                | Число    | Комплексное | Действительное | Рациональное | Целое  |
|--------------------|----------|-------------|----------------|--------------|--------|
| `int`             | +        | +           | +              | +            | +      |
| `fractions.Fraction` | +        | +           | +              | +            |        |
| `float`           | +        | +           | +              |              |        |
| `complex`         | +        | +           |                |              |        |
| `decimal.Decimal` | +        |             |                |              |        |


Таким образом, типы и абстрактные базовые классы помогают работать с различными объектами и типами данных, предоставляя способы их проверки и упрощая работу с типизированными коллекциями и числами.

## Строки

Строки в Python являются неизменяемыми последовательностями символов. Для работы с ними существует множество методов, которые позволяют изменять их представление, искать подстроки, заменять части строки и т.д.

### Основные методы строк:

1. **Удаление пробелов с концов:**
    
    - `strip()`: удаляет пробелы с обоих концов строки.
    - `lstrip()` и `rstrip()` удаляют пробелы только с левого и правого концов соответственно.
    - Вы можете передать символы для удаления:
        
        ```python
        s = '***Hello***'
        s = s.strip('*')  # Удаляет звездочки с обоих концов
        ```
        
2. **Разделение строки:**
    
    - `split()`: разделяет строку по пробелам, можно указать максимальное количество разделений:
        
        ```python
        s = 'apple orange banana'
        words = s.split()  # ['apple', 'orange', 'banana']
        ```
        
    - `split(sep=None, maxsplit=-1)`: позволяет задать разделитель и ограничить количество разбиений.
    - `splitlines()`: разделяет строку на строки по символам новой строки (по умолчанию `\n`, `\r`, `\r\n`).
3. **Соединение элементов:**
    
    - `join()`: соединяет элементы коллекции (например, список строк) в одну строку с указанным разделителем:
        
        ```python
        words = ['apple', 'orange', 'banana']
        s = ', '.join(words)  # 'apple, orange, banana'
        ```
        
4. **Поиск подстроки:**
    
    - `in`: проверяет, содержится ли подстрока в строке:
        
        ```python
        'apple' in 'apple pie'  # True
        ```
        
    - `startswith()`: проверяет, начинается ли строка с подстроки.
    - `find()`: возвращает индекс первого вхождения подстроки или `-1`, если не найдено.
    - `index()`: аналогично `find()`, но вызывает ошибку `ValueError`, если подстрока не найдена.
5. **Изменение регистра:**
    
    - `lower()`, `upper()`: преобразуют строку в нижний или верхний регистр.
    - `capitalize()`: делает первую букву строки заглавной, остальные — строчными.
    - `title()`: преобразует каждое слово в строке, делая его заглавным.
6. **Замена частей строки:**
    
    - `replace(old, new [, count])`: заменяет все вхождения подстроки `old` на подстроку `new` (по желанию ограничив количество замен).
        
        ```python
        s = 'apple orange apple'
        s = s.replace('apple', 'banana')  # 'banana orange banana'
        ```
        
7. **Таблица преобразования:**
    
    - `translate()`: позволяет выполнить замену символов на основе таблицы преобразования, созданной с помощью `str.maketrans()`.
        
        ```python
        table = str.maketrans('abc', '123')
        s = 'abc'
        s = s.translate(table)  # '123'
        ```
        
8. **Преобразование символов Юникода:**
    
    - `chr(<int>)`: преобразует число в символ Юникода.
    - `ord(<str>)`: преобразует символ Юникода в его числовой код.
9. **Нормализация строк (для сравнения строк с особыми символами):**
    
    - Если строка содержит специальные символы, например, с диакритическими знаками, перед сравнением рекомендуется нормализовать строки с помощью `unicodedata.normalize()`:
        
        ```python
        import unicodedata
        s = 'Motörhead'
        normalized_s = unicodedata.normalize("NFC", s)  # Нормализация строки в формат NFC
        ```
        

#### Примеры:

```python
# Пример 1: Удаление пробелов
s = '   Hello World!   '
print(s.strip())  # 'Hello World!'

# Пример 2: Разделение строки
s = 'apple orange banana'
print(s.split())  # ['apple', 'orange', 'banana']

# Пример 3: Проверка на подстроку
print('apple' in 'apple pie')  # True

# Пример 4: Замена текста
s = 'apple orange apple'
print(s.replace('apple', 'banana'))  # 'banana orange banana'

# Пример 5: Преобразование регистра
s = 'hello'
print(s.upper())  # 'HELLO'

# Пример 6: Нормализация строки
import unicodedata
s = 'Motörhead'
normalized_s = unicodedata.normalize("NFC", s)
print(normalized_s)  # 'Motörhead'
```


### Методы строк для проверки свойств

1. **`isdecimal()`** — Проверяет, состоит ли строка только из десятичных цифр (например, `0-9`, `०-९`, `٠-٩`):
    
    ```python
    s = '12345'
    print(s.isdecimal())  # True
    ```
    
2. **`isdigit()`** — Проверяет, является ли строка цифрой. Это включает в себя степени (например, `²`, `³`):
    
    ```python
    s = '²'
    print(s.isdigit())  # True
    ```
    
3. **`isnumeric()`** — Проверяет, является ли строка числом, включая различные формы чисел, такие как дроби и числа на других языках:
    
    ```python
    s = 'Ⅻ'  # Римская цифра 12
    print(s.isnumeric())  # True
    ```
    
4. **`isalnum()`** — Проверяет, состоит ли строка только из букв и цифр:
    
    ```python
    s = 'abc123'
    print(s.isalnum())  # True
    ```
    
5. **`isprintable()`** — Проверяет, является ли строка "печатаемой", т.е. не содержит ли она не-печатаемых символов:
    
    ```python
    s = 'Hello!'
    print(s.isprintable())  # True
    ```
    
6. **`isspace()`** — Проверяет, состоит ли строка только из пробельных символов (пробелы, табуляция, новая строка и другие):
    
    ```python
    s = '   \t\n'
    print(s.isspace())  # True
    ```
    

---

## Регулярные выражения

Для работы с регулярными выражениями в Python используется модуль `re`, который предоставляет несколько мощных функций для поиска и замены текста.

1. **`re.sub(r'<regex>', new, text, count=0)`** — Заменяет все вхождения шаблона `regex` на строку `new` в тексте. Параметр `count` ограничивает количество замен:
    
    ```python
    import re
    text = 'hello world'
    result = re.sub(r'world', 'Python', text)  # 'hello Python'
    ```
    
2. **`re.findall(r'<regex>', text)`** — Находит все вхождения шаблона в строке и возвращает их в виде списка:
    
    ```python
    text = 'apple orange banana apple'
    matches = re.findall(r'apple', text)  # ['apple', 'apple']
    ```
    
3. **`re.split(r'<regex>', text, maxsplit=0)`** — Разбивает строку на части по регулярному выражению, ограничивает количество разбиений:
    
    ```python
    text = 'apple, orange, banana'
    result = re.split(r', ', text)  # ['apple', 'orange', 'banana']
    ```
    
4. **`re.search(r'<regex>', text)`** — Находит первое вхождение шаблона в строке и возвращает объект `Match` или `None`, если ничего не найдено:
    
    ```python
    text = 'apple orange banana'
    match = re.search(r'orange', text)
    if match:
        print(match.group())  # orange
    ```
    
5. **`re.match(r'<regex>', text)`** — Проверяет, начинается ли строка с шаблона:
    
    ```python
    text = 'apple orange banana'
    match = re.match(r'apple', text)
    if match:
        print(match.group())  # apple
    ```
    
6. **`re.finditer(r'<regex>', text)`** — Возвращает итератор по всем вхождениям шаблона в строке в виде объектов `Match`:
    
    ```python
    text = 'apple orange apple'
    for match in re.finditer(r'apple', text):
        print(match.group())  # apple, apple
    ```
    

---

#### Сопоставление объекта `Match`

- **`group()`** — Возвращает весь найденный фрагмент:
    
    ```python
    match = re.search(r'apple', 'apple orange apple')
    print(match.group())  # apple
    ```
    
- **`group(1)`** — Возвращает часть строки, заключенную в первые круглые скобки регулярного выражения:
    
    ```python
    match = re.search(r'(\w+) (\w+)', 'apple orange')
    print(match.group(1))  # apple
    ```
    
- **`groups()`** — Возвращает все части строки, заключенные в круглые скобки:
    
    ```python
    match = re.search(r'(\w+) (\w+)', 'apple orange')
    print(match.groups())  # ('apple', 'orange')
    ```
    
- **`start()`** и **`end()`** — Возвращают стартовый и конечный индексы найденного фрагмента:
    
    ```python
    match = re.search(r'apple', 'apple orange apple')
    print(match.start())  # 0
    print(match.end())    # 5
    ```
    

---

#### Специальные символы в регулярных выражениях

- **`'\d'`** — Совпадает с любым десятичным числом:
    
    ```python
    re.match(r'\d', '1')  # Совпадает
    ```
    
- **`'\w'`** — Совпадает с любым буквой, цифрой или символом подчеркивания:
    
    ```python
    re.match(r'\w', 'a')  # Совпадает
    ```
    
- **`'\s'`** — Совпадает с любым пробельным символом:
    
    ```python
    re.match(r'\s', ' ')  # Совпадает
    ```
    

### Флаги

- **`re.IGNORECASE`** — Игнорирует регистр при сопоставлении.
- **`re.MULTILINE`** — `^` и `$` будут соответствовать началу и концу каждой строки, а не всей строки.
- **`re.DOTALL`** — Символ `.` будет сопоставляться с символом новой строки `\n`.

### Пример с флагами:

```python
import re
text = 'apple\nbanana'
match = re.search(r'^banana', text, flags=re.MULTILINE)
if match:
    print(match.group())  # banana
```

## Форматирование

Python поддерживает несколько способов форматирования строк. Вот основные способы:

1. **Использование f-строк (f-string):**
    
    ```python
    <str> = f'{<el_1>}, {<el_2>}'
    ```
    
    Это самый современный и удобный способ форматирования строк, который был добавлен в Python 3.6. Здесь можно использовать любые выражения внутри фигурных скобок. Пример:
    
    ```python
    name = 'Alice'
    age = 30
    print(f'{name} is {age} years old.')  # Alice is 30 years old.
    ```
    
2. **Метод `.format()`:**
    
    ```python
    <str> = '{}, {}'.format(<el_1>, <el_2>)
    ```
    
    Этот метод является старым способом форматирования, но все еще широко используется. С помощью `.format()` можно передавать параметры в строку, используя их позиции или имена:
    
    ```python
    name = 'Bob'
    height = 175
    print('{} is {} cm tall'.format(name, height))  # Bob is 175 cm tall
    ```
    
3. **Использование оператора `%`:**
    
    ```python
    <str> = '%s, %s' % (<el_1>, <el_2>)
    ```
    
    Это старый стиль форматирования, часто называемый "C-стилем". Хотя его использование не рекомендуется, он все еще поддерживается в Python:
    
    ```python
    name = 'Charlie'
    age = 25
    print('%s is %d years old' % (name, age))  # Charlie is 25 years old
    ```
    

#### Пример с использованием `namedtuple`

```python
import collections

Person = collections.namedtuple('Person', 'name height')
person = Person('Jean-Luc', 187)
print(f'{person.name} is {person.height / 100} meters tall.')  # Jean-Luc is 1.87 meters tall.
```

#### Общие опции форматирования

1. **Выравнивание текста:**
    
    - **`{<el>:<10}`** — выравнивание по левому краю с шириной 10:
        
        ```python
        text = 'apple'
        print(f'{text:<10}')  # 'apple     '
        ```
        
    - **`{<el>:^10}`** — выравнивание по центру с шириной 10:
        
        ```python
        text = 'apple'
        print(f'{text:^10}')  # '  apple   '
        ```
        
    - **`{<el>:>10}`** — выравнивание по правому краю с шириной 10:
        
        ```python
        text = 'apple'
        print(f'{text:>10}')  # '     apple'
        ```
        
2. **Дополнительные символы для форматирования:**
    
    - **`{<el>:.<10}`** — добавление точек до ширины 10:
        
        ```python
        text = 'apple'
        print(f'{text:.<10}')  # 'apple.....'
        ```
        
3. **Заполнение нулями:**
    
    - **`{<el>:0}`** — убирает все пробелы:
        
        ```python
        text = 'apple'
        print(f'{text:0}')  # apple
        ```
        

#### Дополнительные функции форматирования

- **Динамическая генерация параметров:** Вы можете генерировать параметры для форматирования динамически.
    
    ```python
    width = 10
    text = 'apple'
    print(f'{text:{width}}')  # 'apple     '
    ```
    
- **Использование `=` для вывода выражений в f-строках:**
    
    ```python
    print(f'{1+1=}')  # 1+1=2
    ```
    
- **Использование `!r` для вызова метода `repr()`:**
    
    ```python
    obj = 'hello'
    print(f'{obj!r}')  # 'hello'
    ```
    

Эти способы позволяют гибко форматировать строки в Python, делая код более читаемым и компактным.
```

### Числа
```python
{123456:10}                              # '    123456'
{123456:10,}                             # '   123,456'
{123456:10_}                             # '   123_456'
{123456:+10}                             # '   +123456'
{123456:=+10}                            # '+   123456'
{123456: }                               # ' 123456'
{-123456: }                              # '-123456'
```

### Форматирование чисел с плавающей точкой в Python

Python поддерживает различные способы форматирования чисел с плавающей точкой для вывода в строках, включая представления с фиксированным числом знаков после запятой, в экспоненциальной форме, а также в процентах.

#### Примеры форматирования чисел с плавающей точкой

1. **Округление до заданного числа знаков после запятой:**
    
    ```python
    {1.23456:10.3}   # '      1.23' — округление до 3 знаков после запятой.
    {1.23456:10.3f}  # '     1.235' — округление до 3 знаков после запятой с фиксированной точкой.
    {1.23456:10.3e}  # ' 1.235e+00' — экспоненциальная форма с точностью до 3 знаков.
    {1.23456:10.3%}  # '  123.456%' — процентное представление с точностью до 3 знаков.
    ```
    
2. **Сравнение различных типов отображения:**
    
| Число       | {}           | {:f}        | {:e}           | {:%}           |
| ----------- | ------------ | ----------- | -------------- | -------------- |
| 0.000056789 | '5.6789e-05' | '0.000057'  | '5.678900e-05' | '0.005679%'    |
| 0.00056789  | '0.00056789' | '0.000568'  | '5.678900e-04' | '0.056789%'    |
| 0.0056789   | '0.0056789'  | '0.005679'  | '5.678900e-03' | '0.567890%'    |
| 0.056789    | '0.056789'   | '0.056789'  | '5.678900e-02' | '5.678900%'    |
| 0.56789     | '0.56789'    | '0.567890'  | '5.678900e-01' | '56.789000%'   |
| 5.6789      | '5.6789'     | '5.678900'  | '5.678900e+00' | '567.890000%'  |
| 56.789      | '56.789'     | '56.789000' | '5.678900e+01' | '5678.900000%' |
    
3. **Форматирование с меньшей точностью:**
    
| Число       | {:.2}     | {:.2f}  | {:.2e}     | {:.2%}     |
| ----------- | --------- | ------- | ---------- | ---------- |
| 0.000056789 | '5.7e-05' | '0.00'  | '5.68e-05' | '0.01%'    |
| 0.00056789  | '0.00057' | '0.00'  | '5.68e-04' | '0.06%'    |
| 0.0056789   | '0.0057'  | '0.01'  | '5.68e-03' | '0.57%'    |
| 0.056789    | '0.057'   | '0.06'  | '5.68e-02' | '5.68%'    |
| 0.56789     | '0.57'    | '0.57'  | '5.68e-01' | '56.79%'   |
| 5.6789      | '5.7'     | '5.68'  | '5.68e+00' | '567.89%'  |
| 56.789      | '5.7e+01' | '56.79' | '5.68e+01' | '5678.90%' |
    
4. **Специальное форматирование:**
    
    - **`'{<float>:g}'`** — автоматически выбирает наиболее подходящий формат (фиксированная точка или экспоненциальная форма), удаляя избыточные нули:
        
        ```python
        print(f'{0.00056789:g}')  # '0.00056789'
        ```
        
    - **Округление с четной последней цифрой:** Когда число находится на полпути (например, 6.5), Python округляет его к ближайшему четному числу:
        
        ```python
        print(f'{6.5:.0f}')  # '6'
        print(f'{7.5:.0f}')  # '8'
        ```
        

### Форматирование целых чисел

1. **Символы:**
    
    - **`{90:c}`** — символ Юникода, представленный числом:
        
        ```python
        print(f'{90:c}')  # 'Z'
        ```
        
2. **Числа в разных системах счисления:**
    
    - **`{90:b}`** — число в двоичной системе:
        
        ```python
        print(f'{90:b}')  # '1011010'
        ```
        
    - **`{90:X}`** — число в шестнадцатеричной системе (с заглавными буквами):
        
        ```python
        print(f'{90:X}')  # '5A'
        ```
        

Эти способы форматирования чисел помогают сделать вывод более гибким и читаемым, а также позволяют корректно управлять точностью и представлением чисел в различных форматах.```


-------
```python
<int>      = int(<float/str/bool>)                # Или: math.trunc(<float>)
<float>    = float(<int/str/bool>)                # Или: <int/float>e±<int>
<complex>  = complex(real=0, imag=0)              # Или: <int/float> ± <int/float>j
<Fraction> = fractions.Fraction(0, 1)             # Или: Fraction(numerator=0, denominator=1)
<Decimal>  = decimal.Decimal(<str/int>)           # Или: Decimal((sign, digits, exponent))
```
* **`'int(<str>)'` и `'float(<str>)'` вызывают ValueError для некорректных строк.**
* **Десятичные числа хранятся точно, в отличие от большинства чисел с плавающей точкой, где `'1.1 + 2.2 != 3.3'`.**
* **Числа с плавающей точкой можно сравнивать с помощью: `'math.isclose(<float>, <float>)'`.**
* **Точность десятичных операций задается с помощью: `'decimal.getcontext().prec = <int>'`.**

## Работа с числами в Python

Python предоставляет несколько типов данных для работы с числами, а также различные функции и операторы для их обработки.

#### Преобразование типов

1. **Преобразование в целое число:**
    
    ```python
    <int> = int(<float/str/bool>)  # Преобразование из float, строки или булевого значения в целое число.
    ```
    
    Пример:
    
    ```python
    int('10')  # 10
    int(3.14)  # 3
    ```
    
2. **Преобразование в число с плавающей точкой:**
    
    ```python
    <float> = float(<int/str/bool>)  # Преобразование из целого числа или строки в число с плавающей точкой.
    ```
    
    Пример:
    
    ```python
    float('3.14')  # 3.14
    float(10)      # 10.0
    ```
    
3. **Комплексные числа:**
    ```python
    <complex> = complex(real=0, imag=0)  # Преобразование в комплексное число.
    complex(1, 2)  # (1 + 2j)
    ```
    
4. **Дроби (fractions):**
    
    ```python
    <Fraction> = fractions.Fraction(0, 1)  # Представление дроби.
    from fractions import Fraction
    f = Fraction(1, 3)  # 1/3
    ```
    
5. **Десятичные числа (Decimal):**
    
    ```python
    <Decimal> = decimal.Decimal(<str/int>)  # Десятичные числа, более точные, чем float.
    from decimal import Decimal
    d = Decimal('1.1')  # 1.1
    ```
    
---
#### Основные функции

1. **Возведение в степень:**
    
    ```python
    <num> = pow(<num>, <num>)  # Эквивалент <num> ** <num>
    pow(2, 3)  # 8
    ```
    
2. **Абсолютное значение:**
    
    ```python
    <num> = abs(<num>)  # Возвращает абсолютное значение числа.
    abs(-5)  # 5
    ```
    
3. **Округление:**
    
    ```python
    <num> = round(<num>, ndigits)  # Округление числа до заданного количества знаков после запятой.
    round(5.6789, 2)  # 5.68
    ```
    
---
#### Библиотека math

1. **Основные математические константы и функции:**
    
    ```python
    from math import e, pi, inf, nan  # e, pi, бесконечность и NaN
    from math import sin, cos, tan  # Тригонометрические функции
    from math import log, log10, log2  # Логарифмы
    ```
    
2. **Пример:**
    
    ```python
    from math import sin, pi
    sin(pi / 2)  # 1.0
    ```
    
---
#### Статистика

1. **Основные статистические функции:**
    
    ```python
    from statistics import mean, median, variance
    data = [1, 2, 3, 4, 5]
    mean(data)  # 3
    ```
    
---
#### Работа с случайными числами (random)

1. **Генерация случайных чисел:**
    
    ```python
    from random import random, randint, choice
    random()  # Случайное число от 0 до 1
    randint(1, 10)  # Случайное целое число от 1 до 10
    ```
    
---
#### Преобразование в двоичный и шестнадцатеричный формат

1. **Двоичные и шестнадцатеричные строки:**
    
    ```python
    bin(90)  # '0b1011010'
    hex(90)  # '0x5a'
    ```
    
2. **Преобразование строки в число:**
    
    ```python
    int('1011010', 2)  # 90
    int('5a', 16)      # 90
    ```
    
---
#### Побитовые операторы

1. **Операции побитового И, ИЛИ, XOR, сдвигов:**
    
    ```python
    0b1100 & 0b1010  # 0b1000 (И)
    0b1100 | 0b1010  # 0b1110 (ИЛИ)
    0b1100 ^ 0b1010  # 0b0110 (XOR)
    0b1100 << 2      # 0b110000 (Сдвиг влево на 2 бита)
    ~0b1100          # -0b1101 (Операция NOT)
    ```
    
---
## Комбинаторика

Модуль `itertools` предоставляет удобные функции для работы с последовательностями и генерации различных комбинаций, перестановок и произведений. Вот несколько полезных примеров:

#### 1. **Произведение (product)**

Функция `it.product()` генерирует декартово произведение элементов из переданных последовательностей. Можно также указать количество повторений.

```python
import itertools as it

# Пример с повторениями
list(it.product([0, 1], repeat=3))
# Результат: [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1),
#             (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
```

#### 2. **Комбинации (combinations)**

Функция `it.combinations()` генерирует все возможные комбинации элементов последовательности фиксированной длины.

```python
# Пример с комбинациями длины 2 из строки 'abc'
list(it.combinations('abc', 2))
# Результат: [('a', 'b'), ('a', 'c'), ('b', 'c')]
```

#### 3. **Комбинации с повторениями (combinations_with_replacement)**

Функция `it.combinations_with_replacement()` генерирует все возможные комбинации с повторениями.

```python
# Пример с комбинациями с повторениями длины 2 из строки 'abc'
list(it.combinations_with_replacement('abc', 2))
# Результат: [('a', 'a'), ('a', 'b'), ('a', 'c'), ('b', 'b'), ('b', 'c'), ('c', 'c')]
```

#### 4. **Перестановки (permutations)**

Функция `it.permutations()` генерирует все возможные перестановки элементов последовательности фиксированной длины.

```python
# Пример с перестановками длины 2 из строки 'abc'
list(it.permutations('abc', 2))
# Результат: [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')]
```

#### Использование:

- **`it.product()`** подходит для генерации всех возможных сочетаний элементов из нескольких последовательностей.
- **`it.combinations()`** полезна, когда вам нужно получить все возможные подмножества фиксированной длины без повторений.
- **`it.combinations_with_replacement()`** используется для получения комбинаций с возможностью повторений.
- **`it.permutations()`** используется для генерации всех возможных порядков элементов в последовательности.

## Работа с датами и временем

Модуль `datetime` предоставляет классы для работы с датами, временем и их комбинациями. Он включает такие классы, как `date`, `time`, `datetime` и `timedelta`, каждый из которых обладает различными методами и аттрибутами для работы с временем. Все эти классы неизменяемы и хешируемы.

```python
from datetime import date, time, datetime, timedelta, timezone
import zoneinfo, dateutil.tz
```

#### Основные классы

- **`date(year, month, day)`** — представляет дату (год, месяц, день). Действительные даты принимаются от 1 до 9999 года нашей эры.
- **`time(hour=0, minute=0, second=0)`** — представляет время (часы, минуты, секунды). Дополнительные параметры включают `microsecond`, `tzinfo` и `fold`. Можно указать часы, минуты и секунды, а также микро-секунды и информацию о часовом поясе.
- **`datetime(year, month, day, hour=0)`** — сочетание даты и времени. Аргументы `minute`, `second`, `microsecond` и другие тоже могут быть переданы.
- **`timedelta(weeks=0, days=0, hours=0)`** — представляет собой разницу между двумя временными объектами. Дополнительные параметры: `minutes`, `seconds`, `microseconds`. Его метод `str()` возвращает строку в формате `"[±D, ]H:MM:SS[.…]"`, а метод `total_seconds()` — число с плавающей точкой, представляющее все секунды разницы.

**Основные моменты:**

- **Naive (наивные) объекты** — объекты времени и даты без информации о часовом поясе.
- **Aware (осознанные) объекты** — объекты времени и даты, которые включают информацию о часовом поясе.
- **`fold=1`** — используется в случае перехода времени на летнее время, где один момент времени повторяется дважды (например, при переходе на зимнее время).
- **`weekday()`** — возвращает день недели как целое число (понедельник = 0, воскресенье = 6).

### Получение текущего времени

```python
# Получить текущую дату/время
DT = datetime.today()  # Местное время
DTa = datetime.now(tz=timezone.utc)  # Время с учётом часового пояса
```

- **`datetime.today()`** — возвращает текущую местную дату и время в формате `datetime`.
- **`datetime.now()`** — возвращает текущие дату и время, но с возможностью указания часового пояса (по умолчанию использует местный часовой пояс).
- **`datetime.now(tz=timezone.utc)`** — позволяет указать конкретный часовой пояс для получения времени в нём, например, в UTC.

### Работа с часовыми поясами

- **`timezone.utc`** — часовой пояс UTC.
- **`timezone(timedelta)`** — фиксированное смещение от UTC. Например, для часового пояса с 3-часовым смещением: `timezone(timedelta(hours=3))`.
- **`dateutil.tz.tzlocal()`** — для локального часового пояса, смещение которого меняется в зависимости от времени года (например, при переходе на летнее время).
- **`zoneinfo.ZoneInfo('<iana_key>')`** — часовой пояс, определённый по IANA стандарту, например `"Europe/Moscow"`, с динамическим смещением.

Пример использования:

```python
# Преобразование времени в другой часовой пояс
DT = DT.astimezone(timezone.utc)  # Перевод в UTC
```

- **`astimezone()`** — преобразует объект `datetime` в другой часовой пояс. Этот метод важен для работы с aware объектами.
- **`replace(tzinfo=timezone)`** — изменяет часовой пояс объекта без преобразования времени. Используется, когда необходимо сменить часовой пояс, но оставить время неизменным.

### Преобразование строковых представлений

- **`fromisoformat()`** — используется для преобразования строки ISO 8601 в объект `datetime`. Пример:

```python
DT = datetime.fromisoformat('2025-08-14 23:39:00+02:00')  # ISO 8601
```

- **`strptime()`** — метод для преобразования строки в объект `datetime`, в зависимости от заданного формата.

```python
DT = datetime.strptime('2025-08-14 23:39:00.00 +0200', '%Y-%m-%d %H:%M:%S.%f %z')
```

- **`fromordinal()`** — преобразует количество дней, прошедших с 1 января 1 года, в объект `date` или `datetime`.

```python
# Преобразование порядкового числа в дату
DT = datetime.fromordinal(737000)  # Число дней с 1 января 1 года
```

- **`fromtimestamp()`** — преобразует количество секунд, прошедших с эпохи Unix (1970-01-01 00:00:00 UTC), в объект `datetime`.

```python
DT = datetime.fromtimestamp(1633072800)  # Местное время по эпохе
```

- **`fromtimestamp()` с указанием часового пояса**:

```python
DTa = datetime.fromtimestamp(1633072800, tz=timezone.utc)  # Время по UTC
```

### Форматирование объектов даты и времени

Для преобразования объекта `datetime` в строку с заданным форматом используется метод **`strftime()`**:

```python
formatted = DT.strftime("%dth of %B '%y (%a), %I:%M %p %Z")
# Пример: "14th of August '25 (Thu), 11:39 PM UTC+02:00"
```

Вот некоторые полезные форматы для **`strftime()`**:

- **`%Y`** — год (полный, например, 2025).
- **`%m`** — месяц (01–12).
- **`%d`** — день месяца (01–31).
- **`%H`** — часы (00–23).
- **`%M`** — минуты (00–59).
- **`%S`** — секунды (00–59).
- **`%f`** — микросекунды (000000–999999).
- **`%z`** — часовой пояс в формате `±HH:MM`.
- **`%Z`** — название часового пояса.

### Арифметика с датами и временем

#### Разница между двумя датами

```python
delta = DT - datetime(2023, 8, 14)  # Разница между датами
```

- Результатом является объект `timedelta`, который можно использовать для вычислений.

#### Прибавление времени

```python
new_dt = DT + timedelta(days=5)  # Прибавляем 5 дней к текущей дате
```

#### Получение секунд разницы

```python
seconds = delta.total_seconds()  # Получаем разницу в секундах
```

### Примеры арифметики с `timedelta`

- **Сложение и вычитание**:

```python
# Сложение timedelta с datetime
new_dt = DT + timedelta(days=2, hours=5)

# Вычитание datetime объектов
delta = DT - datetime(2023, 8, 14)
```

- **Деление timedelta на число** (например, перевод разницы времени в часы):

```python
hours = delta.total_seconds() / 3600  # Количество часов
```

### Сравнение дат и времени

```python
# Сравнение двух объектов datetime
result = DT > datetime(2023, 1, 1)  # Проверка, больше ли одна дата другой
```

#### Часовые пояса и их обработка

- **`zoneinfo.ZoneInfo()`** может использоваться для динамических часовых поясов, например для перехода на летнее время.
- **`astimezone()`** позволяет переводить дату и время в другой часовой пояс.
- **`replace(tzinfo=timezone)`** позволяет изменить часовой пояс объекта без изменения времени.

#### Пример использования с `timedelta`

```python
# Создание временной разницы
delta = timedelta(days=2, hours=5)

# Добавление к datetime
new_time = DT + delta
```

# Синтаксис
## Аргументы в Python

В Python функции могут принимать различные типы аргументов, включая позиционные, ключевые, и специальные операторы, такие как **splat** и **splatty-splat** для работы с коллекциями.

#### Внутренний вызов функции

Когда мы вызываем функцию, мы можем передавать ей аргументы двумя основными способами:

1. **Позиционные аргументы** — аргументы, передаваемые в функции в определённом порядке.
    
    ```python
    func(0, 0)  # 0 и 0 - позиционные аргументы
    ```
    
2. **Ключевые аргументы** — аргументы, передаваемые с указанием имени параметра.
    
    ```python
    func(x=0, y=0)  # x=0 и y=0 - ключевые аргументы
    ```
    
3. **Комбинированный вызов** — передача как позиционных, так и ключевых аргументов.
    
    ```python
    func(0, y=0)  # 0 - позиционный аргумент, y=0 - ключевой
    ```
    

#### Внутреннее определение функции

При определении функции мы также можем использовать различные типы аргументов:

1. **Без значений по умолчанию** (т.е. обязательные аргументы):
    
    ```python
    def func(x, y):  # Обязательные аргументы x и y
        pass
    ```
    
2. **С значениями по умолчанию**:
    
    ```python
    def func(x=0, y=0):  # Аргументы x и y имеют значения по умолчанию
        pass
    ```
    
3. **Смешанный вариант** — обязательные и необязательные аргументы:
    
    ```python
    def func(x, y=0):  # x обязателен, y имеет значение по умолчанию
        pass
    ```
    

**Важное замечание:** Значения по умолчанию оцениваются только один раз, при первом определении функции. Если аргумент имеет изменяемое значение (например, список), то изменения будут сохраняться между вызовами.

### Оператор Splat

**Splat (`*`)** и **Splatty-splat (`**`)** используются для работы с коллекциями, чтобы развернуть их в позиционные или ключевые аргументы.

1. **Вызов функции с использованием splat:**
    - **`*args`** — разворачивает коллекцию на позиционные аргументы.
    - **`**kwargs`** — разворачивает словарь на аргументы ключевых слов.

Пример:

```python
args = (1, 2)
kwargs = {'x': 3, 'y': 4, 'z': 5}
func(*args, **kwargs)
```

Это эквивалентно:

```python
func(1, 2, x=3, y=4, z=5)
```

2. **Определение функции с использованием splat:**

- **`*args`** — собирает все позиционные аргументы в кортеж.
    
    ```python
    def add(*args):
        return sum(args)
    
    add(1, 2, 3)  # 6
    ```
    
- **`**kwargs`** — собирает все ключевые аргументы в словарь.
    
    ```python
    def print_kwargs(**kwargs):
        print(kwargs)
    
    print_kwargs(x=1, y=2)  # {'x': 1, 'y': 2}
    ```
    

#### Комбинированные аргументы

Функции могут иметь несколько типов аргументов в одном определении:

1. **Только позиционные аргументы**:
    
    ```python
    def f(*args):
        pass
    ```
    
2. **Позиционные аргументы + обязательные аргументы**:
    
    ```python
    def f(x, *args):
        pass
    ```
    
3. **Позиционные и ключевые аргументы**:
    
    ```python
    def f(*args, z):
        pass
    ```
    
4. **Ключевые аргументы**:
    
    ```python
    def f(**kwargs):
        pass
    ```
    
5. **Позиционные и ключевые аргументы с обязательным первым аргументом**:
    
    ```python
    def f(x, *args, **kwargs):
        pass
    ```
    
6. **Обязательные ключевые аргументы** — с использованием `*`:
    
    ```python
    def f(*, x, y, z):
        pass
    ```
    
7. **Позиционные и обязательные ключевые аргументы**:
    
    ```python
    def f(x, *, y, z):
        pass
    ```
    
8. **Позиционные и ключевые аргументы с опциональными ключевыми**:
    
    ```python
    def f(x, y, *, z):
        pass
    ```
    

#### Другие варианты использования оператора Splat

- **Распаковка коллекций в новые коллекции:**
    
    - Распаковка списка в новый список:
        
        ```python
        list_copy = [*some_list]
        ```
        
    - Распаковка в кортеж:
        
        ```python
        tuple_copy = (*some_list,)
        ```
        
    - Распаковка в множество:
        
        ```python
        set_copy = {*some_list}
        ```
        
    - Распаковка в новый словарь:
        
        ```python
        dict_copy = {**some_dict}
        ```
        
- **Распаковка коллекций с добавлением новых элементов:** Пример с использованием `*` для распаковки элементов коллекции:
    
    ```python
    head, *body, tail = some_list  # Голова и хвост могут быть опущены
    ```
    

### Пример комбинированного использования

```python
def f(x, *args, y=2, **kwargs):
    print(x, args, y, kwargs)

f(1, 2, 3, y=4, z=5)
# Вывод: 1 (2, 3) 4 {'z': 5}
```

В этом примере:

- `x` является обязательным аргументом.
- `*args` собирает все дополнительные позиционные аргументы.
- `y` имеет значение по умолчанию, но может быть переопределён.
- `**kwargs` собирает все дополнительные аргументы, переданные как ключевые.

С использованием оператора Splat можно элегантно управлять аргументами функций и легко работать с коллекциями данных.

## Встроенные функции

1. **Lambda функции**
    
    Лямбда-функции — это анонимные функции, которые обычно используют для кратких операций, где не нужно определять полноценную функцию с именем.
    
    Примеры:
    
    ```python
    func = lambda: 5  # Функция без аргументов, возвращающая 5
    print(func())  # Вывод: 5
    ```
    
    Лямбда-функция с аргументами:
    
    ```python
    func = lambda x, y: x + y  # Функция с двумя аргументами
    print(func(2, 3))  # Вывод: 5
    ```
    
    Лямбда-функции также могут иметь аргументы по умолчанию:
    
    ```python
    func = lambda x=1, y=2: x + y  # Аргументы с значениями по умолчанию
    print(func())  # Вывод: 3
    ```
    
2. **Comprehension (генераторы и списковые выражения)**
    
    Comprehension — это конструкция для создания коллекций (списки, множества, словари) в компактной и читаемой форме.
    
    Примеры:
    
    - **Список (List comprehension):**
        
        ```python
        lst = [i + 1 for i in range(10)]  # Создает список с элементами от 1 до 10
        print(lst)  # Вывод: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        ```
        
    - **Генератор (Generator comprehension):**
        
        ```python
        gen = (i for i in range(10) if i > 5)  # Генератор чисел больше 5
        print(list(gen))  # Вывод: [6, 7, 8, 9]
        ```
        
    - **Множество (Set comprehension):**
        
        ```python
        st = {i + 5 for i in range(10)}  # Создает множество с элементами от 5 до 14
        print(st)  # Вывод: {5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
        ```
        
    - **Словарь (Dictionary comprehension):**
        
        ```python
        dct = {i: i * 2 for i in range(10)}  # Создает словарь с ключами и значениями
        print(dct)  # Вывод: {0: 0, 1: 2, 2: 4, 3: 6, 4: 8, 5: 10, 6: 12, 7: 14, 8: 16, 9: 18}
        ```
        
    - **Генератор с несколькими вложенными циклами:**
        
        ```python
        result = [l + r for l in 'abc' for r in 'abc']  # Генерация всех комбинаций букв
        print(result)  # Вывод: ['aa', 'ab', 'ac', 'ba', 'bb', 'bc', 'ca', 'cb', 'cc']
        ```
        
3. **Map, Filter, Reduce**
    
    Эти функции используются для функциональной обработки коллекций. Они применяют заданную функцию ко всем элементам коллекции.
    
    - **Map:** Применяет функцию ко всем элементам коллекции.
        
        ```python
        from functools import reduce
        
        iter_map = map(lambda x: x + 1, range(10))  # Все элементы списка увеличиваются на 1
        print(list(iter_map))  # Вывод: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        ```
        
    - **Filter:** Фильтрует элементы коллекции, применяя условие.
        
        ```python
        iter_filter = filter(lambda x: x > 5, range(10))  # Оставляет только те элементы, которые больше 5
        print(list(iter_filter))  # Вывод: [6, 7, 8, 9]
        ```
        
    - **Reduce:** Последовательно применяет функцию ко всем элементам коллекции, сводя их к одному результату.
        
        ```python
        result = reduce(lambda out, x: out + x, range(10))  # Суммирует все элементы коллекции
        print(result)  # Вывод: 45
        ```
        
4. **Any, All**
    
    Функции `any` и `all` проверяют, выполняются ли условия для всех или хотя бы для одного элемента коллекции.
    
    - **any:** Проверяет, истинно ли хотя бы одно значение в коллекции.
        
        ```python
        result = any([0, '', [], None])  # Возвращает True, если хотя бы один элемент истинный
        print(result)  # Вывод: False
        ```
        
    - **all:** Проверяет, истинны ли все значения в коллекции.
        
        ```python
        result = all([1, 2, 3])  # Возвращает True, если все элементы истинные
        print(result)  # Вывод: True
        ```
        
5. **Условное выражение (Ternary operator)**
    
    Условное выражение позволяет выбрать одно из двух значений на основе условия.
    
    Пример:
    
    ```python
    result = 'positive' if 5 > 0 else 'negative'
    print(result)  # Вывод: positive
    ```
    
6. **Именованный кортеж, перечисление, датакласс**
    
    Эти структуры данных помогают эффективно работать с различными типами данных, включая кортежи с именованными полями, перечисления и датаклассы.
    
    - **Именованный кортеж (Namedtuple):**
        
        ```python
        from collections import namedtuple
        
        Point = namedtuple('Point', 'x y')  # Создание именованного кортежа
        point = Point(0, 0)  # Создание экземпляра именованного кортежа
        print(point.x, point.y)  # Вывод: 0 0
        ```
        
    - **Перечисления (Enum):**
        
        ```python
        from enum import Enum
        
        Direction = Enum('Direction', 'N E S W')  # Создание перечисления
        direction = Direction.N  # Использование элемента перечисления
        print(direction)  # Вывод: Direction.N
        ```
        
    - **Датаклассы (Dataclasses):**
        
        ```python
        from dataclasses import make_dataclass
        
        Player = make_dataclass('Player', ['loc', 'dir'])  # Создание датакласса
        player = Player(point, direction)  # Создание экземпляра датакласса
        print(player.loc, player.dir)  # Вывод: Point(x=0, y=0) Direction.N
        ```

## Импорт

**Механизм импорта позволяет использовать код из одного файла в другом, обеспечивая повторное использование и структурирование программы.**

Примеры использования импорта:

1. **Импорт модуля**  
    Если файл содержит код, который нужно использовать в другом файле, его можно импортировать с помощью команды `import`. Например:
    
    ```python
    import math  # Импортирует встроенный модуль math
    print(math.sqrt(16))  # Выводит: 4.0
    ```
    
    Это позволяет использовать все функции и переменные, определенные в модуле `math`, в другом файле.
    
2. **Импорт пакета**  
    Пакет в Python — это коллекция модулей, которая может включать другие модули или подкаталоги. Пакет обычно содержит специальный файл `__init__.py`, который позволяет ему быть распознанным как пакет. Чтобы импортировать пакет:
    
    ```python
    import mypackage  # Импортирует пакет 'mypackage' (необходимо, чтобы в каталоге был файл __init__.py)
    ```
    
3. **Импорт конкретного модуля из пакета**  
    Чтобы импортировать конкретный модуль из пакета:
    
    ```python
    import mypackage.mymodule  # Импортирует модуль 'mymodule' из пакета 'mypackage'
    ```
    
4. **Импорт объекта (функции, класса и т. д.) из модуля**  
    Иногда полезно импортировать только определенные объекты из модуля:
    
    ```python
    from math import sqrt  # Импортирует только функцию sqrt из модуля math
    print(sqrt(16))  # Выводит: 4.0
    ```
    
5. **Относительный импорт**  
    В случае, если модуль находится в другом подкаталоге или пакете, можно использовать относительный импорт:
    
    ```python
    from . import mymodule  # Импортирует модуль 'mymodule' из текущего пакета
    from .subpackage import mymodule  # Импортирует модуль 'mymodule' из подкаталога 'subpackage'
    ```
    
    Относительные импорты полезны для работы с большими проектами, где структура каталогов позволяет логически организовать код.
    

### Основные концепции:

- **Пакет** — это каталог файлов Python, содержащий файлы `.py` и, часто, файл `__init__.py`, который служит для инициализации пакета и может содержать код для настройки пакета.
    
- **Каталог, передаваемый в качестве аргумента командной строке Python**, является корнем для локальных импортов. Это позволяет организовать структуру проекта таким образом, чтобы модули и пакеты могли быть доступны для импорта.
    
- **Механизм инициализации пакетов**: при использовании `import <package>` важно помнить, что это не приводит к автоматическому импорту всех модулей в пакете, если они явно не указаны в файле `__init__.py`.

## Замыкания 

**Замыкание** возникает, когда вложенная функция ссылается на переменную из своей окружающей (ограничивающей) функции, и эта вложенная функция возвращается как результат работы внешней функции. Переменная из внешней функции остается доступной для вложенной функции даже после того, как выполнение внешней функции завершено.

Пример замыкания:

```python
def get_multiplier(a):
    def out(b):
        return a * b  # Вложенная функция ссылается на переменную 'a'
    return out  # Возвращаем вложенную функцию

# Создание функции, которая умножает на 3
multiply_by_3 = get_multiplier(3)
# Вызов возвращенной функции с аргументом 10
print(multiply_by_3(10))  # Выведет: 30
```

В этом примере переменная `a` из функции `get_multiplier` сохраняет свое значение даже после того, как выполнение этой функции завершилось, потому что возвращаемая функция `out` продолжает ссылаться на нее. Таким образом, `multiply_by_3` использует `a = 3`, несмотря на то что `get_multiplier` уже завершила выполнение.

## Функция `partial`

Модуль `functools` предоставляет функцию `partial`, которая позволяет создавать новые функции с предустановленными аргументами. Это полезно, когда нужно создать версию функции с зафиксированными параметрами, которые будут использоваться по умолчанию.

Пример использования `partial`:

```python
from functools import partial

def multiply(a, b):
    return a * b

# Создаем новую функцию, которая всегда умножает на 3
multiply_by_3 = partial(multiply, 3)

# Вызов новой функции с одним аргументом
print(multiply_by_3(10))  # Выведет: 30
```

`partial` полезен, например, в таких случаях, как передача функции с заранее заданными аргументами в другие функции или методы. Это также используется во многих встроенных функциях Python, например, в `defaultdict(<func>)`, `iter(<func>, to_exc)` или `field(default_factory=<func>)` в классе данных.

## Non-Local

Когда функция ссылается на переменную, которая не является локальной, можно использовать ключевое слово `nonlocal`, чтобы указать, что эта переменная должна быть взята из ближайшей внешней области видимости, а не создана как локальная.

Пример использования `nonlocal`:

```python
def get_counter():
    i = 0
    def out():
        nonlocal i  # Используем переменную 'i' из внешней функции
        i += 1
        return i
    return out

# Создание счетчика
counter = get_counter()

# Вызов функции-счетчика несколько раз
print(counter())  # Выведет: 1
print(counter())  # Выведет: 2
print(counter())  # Выведет: 3
```

В этом примере переменная `i` обновляется с каждым вызовом `counter()`. При использовании `nonlocal` мы говорим Python, что переменная `i` должна быть взята из внешней функции `get_counter`, а не быть локальной переменной внутри функции `out`.

**Важно:** Без `nonlocal` переменная `i` была бы локальной для функции `out`, и ее значение не сохранялось бы между вызовами.

## Декораторы

**Декоратор** в Python — это конструкция, которая позволяет обернуть функцию или метод, добавив к ней дополнительную функциональность без изменения самой функции. Это полезно, например, для логирования, кэширования, проверки прав доступа, и многого другого. Декораторы принимают функцию как аргумент, добавляют к ней функциональность и возвращают новую функцию.

### Основная структура декоратора:

```python
@decorator_name
def function_that_gets_passed_to_decorator():
    ...
```

Когда Python встречает `@decorator_name`, он выполняет вызов `decorator_name(function_that_gets_passed_to_decorator)`, оборачивая функцию, переданную в декоратор, в новую функцию с дополнительным функционалом.

#### Пример: Декоратор для отладки

**Декоратор, который выводит имя функции каждый раз при ее вызове.**

```python
from functools import wraps

def debug(func):
    @wraps(func)  # Сохраняет оригинальные метаданные функции
    def out(*args, **kwargs):
        print(func.__name__)  # Выводит имя функции
        return func(*args, **kwargs)  # Вызывает оригинальную функцию
    return out

@debug
def add(x, y):
    return x + y
```

- **`@wraps(func)`** — это декоратор, который копирует метаданные (такие как `__name__`, `__doc__` и другие) из оригинальной функции `func` в функцию `out`. Без использования `wraps`, вызов `add.__name__` вернул бы `'out'` вместо `'add'`.
- Вызов `add(2, 3)` выведет:
    
    ```
    add
    ```
    

#### Пример: Декоратор для кэширования

**Декоратор, который кэширует возвращаемые значения функции.**

```python
from functools import cache

@cache
def fib(n):
    return n if n < 2 else fib(n-2) + fib(n-1)
```

- Кэширование позволяет ускорить выполнение функции, если она часто вызывается с одинаковыми аргументами.
- **Проблема**: Если функция вызывается бесконечно с разными аргументами, кэш может расти бесконтрольно. Чтобы очистить кэш, можно использовать:
    
    ```python
    fib.cache_clear()
    ```
    
- Для ограничения размера кэша можно использовать `@lru_cache(maxsize=10)`, где `maxsize` указывает максимальное количество сохраненных результатов.

### Параметризованный декоратор

Декораторы могут принимать параметры, позволяя настроить поведение декоратора.

```python
from functools import wraps

def debug(print_result=False):
    def decorator(func):
        @wraps(func)
        def out(*args, **kwargs):
            result = func(*args, **kwargs)
            print(func.__name__, result if print_result else '')
            return result
        return out
    return decorator

@debug(print_result=True)
def add(x, y):
    return x + y
```

- В этом примере декоратор `debug` принимает параметр `print_result`, который управляет тем, будет ли выводиться результат работы функции.
- Если вызвать `add(2, 3)`, будет выведено:
    
    ```
    add 5
    ```
    

Если бы декоратор был использован без параметров (`@debug`), то он бы не работал должным образом, так как `debug` ожидал аргумент `print_result`.

## Классы

**Класс** в Python — это шаблон для создания объектов, который определяет набор атрибутов (переменных) и методов (функций), которые могут быть использованы для работы с этими объектами. Классы позволяют создавать пользовательские структуры данных и организовывать код в логические единицы.

### Основная структура класса:

```python
class MyClass:
    def __init__(self, a):
        self.a = a  # Инициализация атрибута

    def __str__(self):
        return str(self.a)  # Строковое представление объекта

    def __repr__(self):
        class_name = self.__class__.__name__  # Имя класса
        return f'{class_name}({self.a!r})'  # Представление объекта для отладки

    @classmethod
    def get_class_name(cls):
        return cls.__name__  # Имя класса
```

#### Пример использования класса:

```python
>>> obj = MyClass(1)
>>> obj.a, str(obj), repr(obj)
(1, '1', 'MyClass(1)')
```

- **Метод `__str__()`** — используется для получения строкового представления объекта, которое должно быть "читаемым" и удобным для человека.
- **Метод `__repr__()`** — возвращает более "техническое" представление объекта, которое может быть использовано для отладки и должно быть однозначным. Если определен только `__repr__()`, Python будет использовать его для `str()`.
- **Метод `@classmethod`** — метод класса, который принимает в качестве первого аргумента сам класс (обычно называемый `cls`), а не объект.

#### Методы, вызывающие `str()`:

- `print(<obj>)`
- `f'{<obj>}'`
- `logging.warning(<obj>)`
- `csv.writer(<file>).writerow([<obj>])`
- `raise Exception(<obj>)`

#### Методы, вызывающие `repr()`:

- `print()` и `str()` при выводе объектов
- `f'{<obj>!r}'`
- Использование объекта в качестве ключа или элемента коллекции
- Некоторые функции, такие как `dataclasses.make_dataclass()` и другие, которые требуют точного представления объектов.

### Наследование

**Наследование** позволяет одному классу наследовать атрибуты и методы другого класса. В Python класс может наследовать только от одного или нескольких других классов.

#### Пример одноуровневого наследования:

```python
class Person:
    def __init__(self, name):
        self.name = name

class Employee(Person):
    def __init__(self, name, staff_num):
        super().__init__(name)  # Вызов конструктора родительского класса
        self.staff_num = staff_num
```

#### Пример множественного наследования:

```python
class A: pass
class B: pass
class C(A, B): pass
```

#### **MRO (Method Resolution Order)**:

MRO определяет порядок, в котором Python ищет методы или атрибуты в родительских классах. Это важно, когда класс наследует несколько классов.

```python
>>> C.mro()
[<class 'C'>, <class 'A'>, <class 'B'>, <class 'object'>]
```

- Python сначала ищет метод в текущем классе (`C`), затем в классах, от которых он наследует, в порядке их перечисления.
- `mro()` возвращает список классов, которые будут проверяться при поиске метода или атрибута.

### Аннотации типов

**Аннотации типов** (или типовые подсказки) в Python помогают указать, какой тип данных ожидается для переменных, аргументов и возвращаемых значений функций. Хотя они не влияют на выполнение программы в CPython, они могут быть полезны для статического анализа с использованием инструментов, таких как **mypy**, **Pydantic** или **Cython**.

#### Основные примеры аннотаций типов:

```python
def add(x: int, y: int) -> int:  # Функция принимает два целых числа и возвращает целое число
    return x + y
```

- Аннотация типов используется для указания типов аргументов и возвращаемого значения.
- В Python 3.9+ доступна возможность использовать обобщенные типы коллекций:

```python
from collections.abc import Iterable, Sequence

name: str = "John"  # Строка
numbers: list[int] = [1, 2, 3]  # Список целых чисел
items: dict[str, int] = {"apple": 5, "banana": 2}  # Словарь, где ключи - строки, а значения - целые числа
```

- **Объединение типов**: с Python 3.10 можно использовать оператор `|` для указания нескольких возможных типов:

```python
value: int | float = 5.6  # Может быть либо int, либо float
```

### Датаклассы

**Датаклассы** предоставляют удобный способ для автоматической генерации методов инициализации (`__init__`), строкового представления (`__repr__`), а также для сравнения объектов (`__eq__`). Это делает код компактным и удобным для работы с данными.

#### Пример использования датаклассов:

```python
from dataclasses import dataclass, field

@dataclass(order=True, frozen=False)
class Point:
    x: float
    y: float
    z: float = 0.0  # Значение по умолчанию для атрибута z
```

- **`order=True`** позволяет автоматически генерировать методы для сравнения объектов.
- **`frozen=True`** делает объект неизменяемым (атрибуты нельзя будет изменять после создания).
- **`field()`** используется для атрибутов с значениями по умолчанию, которые требуют специальной обработки, например, использование `default_factory` для списков и словарей.

Пример с использованием `field()`:

```python
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    friends: list = field(default_factory=list)  # Используем default_factory для списка
```

- Без `default_factory` список был бы общим для всех экземпляров, что приведет к непредсказуемым результатам при изменении объектов.

#### Создание датакласса с помощью `make_dataclass`:

```python
from dataclasses import make_dataclass

Point = make_dataclass('Point', [('x', float), ('y', float)])
p = Point(1.0, 2.0)
```

- Это позволяет динамически создавать классы и их атрибуты.

### Property (Свойства)

**Свойства** позволяют скрыть внутреннюю логику при доступе к атрибутам объекта, создавая методы для геттеров и сеттеров. Это позволяет контролировать чтение и запись значений, а также делать код более чистым.

#### Пример использования `@property`:

```python
class Person:
    def __init__(self, first_name, last_name):
        self._name = [first_name, last_name]

    @property
    def name(self):
        return ' '.join(self._name)

    @name.setter
    def name(self, value):
        self._name = value.split()

person = Person("Guido", "van Rossum")
person.name = '\t Guido  van Rossum \n'  # Устанавливаем значение через сеттер
print(person.name)  # Выводит 'Guido van Rossum', очищая пробелы и символы переноса строки
```

- **`@property`** — позволяет получить атрибут через метод, не вызывая его как функцию.
- **`@<property_name>.setter`** — позволяет задать метод для изменения значения, с возможностью обработки данных перед присваиванием.

С помощью `@property` можно скрывать детали реализации и обеспечить доступ к данным в контролируемом виде.
### Slots

**`__slots__`** — это механизм в Python, который позволяет ограничить набор атрибутов, которые можно присваивать экземплярам класса, тем самым уменьшая объем памяти, занимаемой объектами этого класса. Это особенно полезно, когда необходимо создать много объектов одного класса, и вы хотите сократить потребление памяти, исключив использование динамического словаря для хранения атрибутов.

#### Пример с использованием `__slots__`:

```python
class MyClassWithSlots:
    __slots__ = ['a']  # Только атрибут 'a' будет доступен у экземпляра
    def __init__(self):
        self.a = 1

# Попытка создать атрибут, не перечисленный в __slots__, вызовет ошибку
obj = MyClassWithSlots()
obj.a = 10
# obj.b = 20  # Ошибка: AttributeError: 'MyClassWithSlots' object has no attribute 'b'
```

- **`__slots__`** создает ограничение на атрибуты экземпляров класса. В данном примере у экземпляра может быть только атрибут `a`. Если попытаться создать атрибут, которого нет в списке `__slots__`, возникнет ошибка.
- **Преимущества**: Этот механизм позволяет избежать создания для каждого экземпляра скрытого атрибута `__dict__`, что экономит память. Он особенно полезен для классов, экземпляры которых не будут изменяться динамически, и для работы с большим количеством объектов.
- **Ограничения**: Не позволяет динамически добавлять новые атрибуты к объектам, а также не поддерживает наследование с расширением атрибутов, если родительский класс использует `__slots__`.

### Copy

**`copy`** и **`deepcopy`** — это функции из модуля `copy`, которые позволяют создавать копии объектов. Они различаются тем, как они копируют вложенные объекты.

- **`copy()`** — выполняет **поверхностное копирование** объекта. Это означает, что создается новый объект, но вложенные объекты (например, списки или другие изменяемые типы) остаются ссылками на те же объекты.
    
- **`deepcopy()`** — выполняет **глубокое копирование**, создавая копии всех объектов, на которые ссылается оригинальный объект, включая вложенные объекты.
    

#### Пример использования `copy`:

```python
from copy import copy, deepcopy

# Поверхностное копирование
original_list = [1, 2, [3, 4]]
shallow_copy = copy(original_list)
shallow_copy[2][0] = 99  # Изменим вложенный список

print(original_list)  # [1, 2, [99, 4]] - вложенный список изменен
print(shallow_copy)   # [1, 2, [99, 4]] - вложенный список изменен

# Глубокое копирование
deep_copy = deepcopy(original_list)
deep_copy[2][0] = 100

print(original_list)  # [1, 2, [99, 4]] - вложенный список не изменен
print(deep_copy)      # [1, 2, [100, 4]] - вложенный список изменен
```

- **`copy()`** создает копию самого объекта, но вложенные объекты остаются общими. Это полезно, когда вам нужно создать новый объект, но вложенные структуры данных не нужно копировать.
- **`deepcopy()`** создает новый объект, а также рекурсивно копирует все вложенные объекты, что делает его полезным, когда необходимо полностью изолировать копию от исходного объекта.

## Утиная типизация

**Утиная типизация** — это принцип, согласно которому объекты определяются не по их типу, а по тому, какие методы они поддерживают. Если объект ведет себя как нужный тип (например, имеет нужные методы), то он считается объектом этого типа, независимо от того, что говорит его фактический тип. Этот принцип позволяет создавать гибкие и адаптивные структуры данных и функции.

### Сравнимый (Comparable)

Для того чтобы объект был сравнимым, необходимо определить метод `__eq__()`, который реализует логику проверки на равенство. Если метод `eq()` не переопределен, Python использует `id(self) == id(other)` для сравнения объектов, что, по сути, означает, что объекты равны, если они являются тем же самым объектом в памяти (используется оператор `is`).

#### Пример класса с сравнением:

```python
class MyComparable:
    def __init__(self, a):
        self.a = a
        
    def __eq__(self, other):
        if isinstance(other, type(self)):  # проверяем тип объекта для сравнения
            return self.a == other.a
        return NotImplemented  # если объект другого типа, возвращаем NotImplemented
```

- Если `eq()` возвращает `NotImplemented`, Python проверит метод `__eq__()` другого объекта для правильного сравнения.
- Метод `__ne__()` (неравенство) автоматически работает с объектами, у которых уже есть `eq()`.

### Хешируемый (Hashable)

Для того чтобы объект был хешируемым (мог быть использован в коллекциях, таких как множества и ключи в словарях), необходимо определить как `__eq__()`, так и `__hash()`. Если объект изменяемый и его значение изменяется, его хеш-значение не должно изменяться.

#### Пример хешируемого класса:

```python
class MyHashable:
    def __init__(self, a):
        self._a = a
        
    @property
    def a(self):
        return self._a
    
    def __eq__(self, other):
        if isinstance(other, type(self)):
            return self.a == other.a
        return NotImplemented
    
    def __hash__(self):
        return hash(self.a)  # использование атрибута для вычисления хеш-значения
```

- **Важно:** хешируемые объекты должны иметь одинаковое хеш-значение для объектов, которые считаются равными.
- **Python автоматически делает объекты нехешируемыми**, если они имеют только `__eq__()` и не переопределяют `__hash__()`.

### Сортируемый (Sortable)

Для того чтобы объекты могли быть сравниваемыми по порядку (например, для использования в `sorted()` или `min()`), нужно определить метод `__lt__()` (меньше, чем). Можно также использовать декоратор `@total_ordering`, чтобы автоматически генерировать другие методы сравнения (`__le__()`, `__gt__()`, `__ge__()`), если будет предоставлен хотя бы один из методов `__lt__()`, `__le__()`, `__gt__()`, или `__ge__()`.

#### Пример сортируемого класса:

```python
from functools import total_ordering

@total_ordering
class MySortable:
    def __init__(self, a):
        self.a = a
    
    def __eq__(self, other):
        if isinstance(other, type(self)):
            return self.a == other.a
        return NotImplemented
    
    def __lt__(self, other):
        if isinstance(other, type(self)):
            return self.a < other.a
        return NotImplemented
```

- **`@total_ordering`** генерирует недостающие методы сравнения на основе предоставленных. Например, если вы определяете только `__eq__()` и `__lt__()`, остальные методы (`__le__()`, `__gt__()`, `__ge__()`) будут автоматически сгенерированы.

#### Примечания:

- Функции, такие как `sorted()`, `min()`, `max()`, требуют от объектов поддержания методов сравнения.
- Если у вас есть коллекция строк или других объектов, которые должны быть отсортированы в соответствии с культурными или языковыми нормами, можно использовать `locale.strxfrm` в параметре `key`.

### Пример сортировки строк с учетом локализации:

```python
import locale

locale.setlocale(locale.LC_COLLATE, "en_US.UTF-8")
sorted_list = sorted(["яблоко", "банан", "вишня"], key=locale.strxfrm)
```

## Итератор

**Итератор** в Python — это объект, который реализует два метода: `__next__()` и `__iter__()`. Метод `__next__()` должен возвращать следующий элемент или вызывать исключение `StopIteration`, если элементы закончились. Метод `__iter__()` должен возвращать сам объект, то есть себя (self), чтобы объект мог использоваться в цикле `for` или других конструкциях, которые требуют итератора.

Пример создания итератора:

```python
class Counter:
    def __init__(self):
        self.i = 0
        
    def __next__(self):
        self.i += 1
        return self.i
    
    def __iter__(self):
        return self
```

Использование итератора:

```python
>>> counter = Counter()
>>> next(counter), next(counter), next(counter)
(1, 2, 3)
```

**Основные объекты-итераторы в Python:**

1. **Итераторы последовательностей**: например, итераторы списков, множества.
2. **Итераторы из модуля `itertools`**: например, `count`, `repeat`, `cycle`.
3. **Генераторы**: создаются с помощью функций-генераторов или выражений-генераторов.
4. **Файловые объекты**: возвращаемые функцией `open()`.

---

### Вызываемые

**Вызываемый объект** — это объект, который можно вызвать как функцию. Все функции и классы являются вызываемыми. Проверить, является ли объект вызываемым, можно с помощью функции `callable()` или `isinstance(<obj>, collections.abc.Callable)`.

Пример создаваемого вызываемого объекта:

```python
class Counter:
    def __init__(self):
        self.i = 0
        
    def __call__(self):
        self.i += 1
        return self.i
```

Использование вызываемого объекта:

```python
>>> counter = Counter()
>>> counter(), counter(), counter()
(1, 2, 3)
```

---

### Менеджер контекста

Менеджер контекста в Python — это объект, который реализует методы `__enter__()` и `__exit__()`. Эти методы позволяют использовать объект с оператором `with`, который гарантирует корректное освобождение ресурсов, даже если внутри блока `with` произошло исключение.

1. **`__enter__()`**: метод, который выполняется при входе в блок `with`, часто используется для открытия ресурсов (например, файлов).
2. **`__exit__()`**: метод, который выполняется при выходе из блока `with` и используется для освобождения ресурсов.

Пример создания менеджера контекста:

```python
class MyOpen:
    def __init__(self, filename):
        self.filename = filename
    
    def __enter__(self):
        self.file = open(self.filename)
        return self.file
    
    def __exit__(self, exc_type, exception, traceback):
        self.file.close()
```

Использование менеджера контекста:

```python
>>> with open('test.txt', 'w') as file:
...     file.write('Hello World!')
>>> with MyOpen('test.txt') as file:
...     print(file.read())
Hello World!
```

Метод `__exit__()` может подавлять исключения, если он возвращает `True`. Если он возвращает `False` или не возвращает ничего, исключение будет снова поднято.
### Итерируемые утиные типы

#### Итерируемый

Объект считается итерируемым, если он реализует метод `__iter__()`, который должен возвращать итератор (объект с методом `__next__()`). Это позволяет объекту использоваться в цикле `for` и других конструкциях, которые требуют итерации.

Метод `__contains__()` позволяет использовать оператор `in` для проверки наличия элемента в объекте.

Пример реализации итерируемого объекта:

```python
class MyIterable:
    def __init__(self, a):
        self.a = a
    
    def __iter__(self):
        return iter(self.a)
    
    def __contains__(self, el):
        return el in self.a
```

Использование:

```python
>>> obj = MyIterable([1, 2, 3])
>>> [el for el in obj]
[1, 2, 3]
>>> 1 in obj
True
```

#### Коллекция

Коллекция — это объект, который реализует два метода: `__iter__()` для итерирования и `__len__()` для получения длины коллекции. Это делает объект подходящим для использования с функциями, которые ожидают коллекции, например, `len()` и `in`.

Пример реализации коллекции:

```python
class MyCollection:
    def __init__(self, a):
        self.a = a
    
    def __iter__(self):
        return iter(self.a)
    
    def __contains__(self, el):
        return el in self.a
    
    def __len__(self):
        return len(self.a)
```

#### Последовательность

Последовательность — это объект, который реализует методы `__getitem__()` и `__len__()`. Метод `__getitem__()` позволяет получить элемент по индексу, а `__len__()` возвращает длину последовательности. Эти методы также делают возможным использование объектов с функциями `iter()`, `contains()` и `reversed()`.

Пример реализации последовательности:

```python
class MySequence:
    def __init__(self, a):
        self.a = a
    
    def __iter__(self):
        return iter(self.a)
    
    def __contains__(self, el):
        return el in self.a
    
    def __len__(self):
        return len(self.a)
    
    def __getitem__(self, i):
        return self.a[i]
    
    def __reversed__(self):
        return reversed(self.a)
```

#### Расхождения между глоссарием и ABC

- **Глоссарий** Python определяет итерируемый объект как любой объект, который имеет метод `__iter__()` или `__getitem__()`, а последовательность как объект с методами `__getitem__()` и `__len__()`.
- **ABC** `abc.Iterable` проверяет, имеет ли объект метод `__iter__()`, а `abc.Collection` проверяет наличие методов `__iter__()`, `__contains__()` и `__len__()`. Таким образом, `abc.Iterable` является более базовым типом.

#### ABC последовательность

`abc.Sequence` — это более богатый интерфейс для последовательностей, чем просто `Sequence`. Помимо методов `__getitem__()` и `__len__()`, он включает дополнительные методы, такие как `__reversed__()`, `index()` и `count()`.

Пример реализации ABC последовательности:

```python
from collections import abc

class MyAbcSequence(abc.Sequence):
    def __init__(self, a):
        self.a = a
    
    def __len__(self):
        return len(self.a)
    
    def __getitem__(self, i):
        return self.a[i]
```

#### Таблица обязательных и автоматически доступных методов

|              | Iterable | Collection | Sequence | abc.Sequence |
| ------------ | :------: | :--------: | :------: | :----------: |
| `iter()`     |  Треб.   |   Треб.    |    +     |      +       |
| `contains()` |    +     |     +      |    +     |      +       |
| `len()`      |          |   Треб.    |  Треб.   |    Треб.     |
| `getitem()`  |          |            |  Треб.   |    Треб.     |
| `reversed()` |          |            |    +     |      +       |
| `index()`    |          |            |          |      +       |
| `count()`    |          |            |          |      +       |

- Метод `iter()` требуется для `abc.Iterable`, однако объекты с `__getitem__()` тоже можно использовать в контексте итерируемых объектов.
- Классы, такие как `MutableSequence`, `Set`, `Mapping` и другие, расширяют эти абстрактные базовые классы и могут использовать методы, связанные с изменяемыми коллекциями.


## Enum

**Enum** — это класс именованных констант, которые называются членами перечисления. Это позволяет создать набор именованных значений, которые могут быть использованы как типы данных.

### Основное использование

Для создания перечисления используется класс `Enum`, а также можно использовать функцию `auto()` для автоматического присваивания значений членам перечисления.

```python
from enum import Enum, auto

class MyEnum(Enum):
    FIRST = auto()       # Значение будет автоматически присвоено
    SECOND = 2           # Значение можно задать вручную
    THIRD = (1, 2, 3)    # Значение может быть коллекцией (например, кортежем)
```

### Доступ к членам перечисления

- Доступ к членам можно получить через атрибуты класса `Enum`.

```python
member = MyEnum.FIRST          # Возвращает член MyEnum.FIRST
```

- Вы также можете получить доступ к членам по имени через индекс:

```python
member = MyEnum['SECOND']      # Возвращает MyEnum.SECOND
```

- Чтобы получить значение или имя члена:

```python
name = MyEnum.FIRST.name       # Возвращает 'FIRST'
value = MyEnum.FIRST.value     # Возвращает автоматическое значение (например, 1)
```

- Можно также использовать преобразование через значение:

```python
member = MyEnum(1)             # Возвращает MyEnum.FIRST
```

### Список всех членов перечисления

Для того чтобы получить все члены перечисления, используйте функцию `list()`:

```python
members = list(MyEnum)         # Возвращает [<MyEnum.FIRST: 1>, <MyEnum.SECOND: 2>, <MyEnum.THIRD: (1, 2, 3)>]
```

Чтобы получить только имена или значения членов:

```python
names = [a.name for a in MyEnum]  # ['FIRST', 'SECOND', 'THIRD']
values = [a.value for a in MyEnum]  # [1, 2, (1, 2, 3)]
```

### Итерация по членам перечисления

Перечисления можно перебирать с помощью циклов или функций, например, через итератор:

```python
import itertools

for member in itertools.cycle(MyEnum):  # Возвращает бесконечный итератор
    print(member)
```

Можно также выбрать случайный элемент из перечисления:

```python
import random

random_member = random.choice(list(MyEnum))  # Возвращает случайный член
```

### Встроенные перечисления

Для создания перечислений с использованием встроенных значений можно передать строку, список или словарь в `Enum`:

```python
# С помощью строки
Cutlery = Enum('Cutlery', 'FORK KNIFE SPOON')

# С помощью списка
Cutlery = Enum('Cutlery', ['FORK', 'KNIFE', 'SPOON'])

# С помощью словаря
Cutlery = Enum('Cutlery', {'FORK': 1, 'KNIFE': 2, 'SPOON': 3})
```

### Использование пользовательских функций как значений

В значениях перечислений можно использовать не только простые значения, но и функции. Однако, так как функции не могут быть значениями перечисления напрямую, их нужно обернуть с помощью, например, `partial`:

```python
from functools import partial

LogicOp = Enum('LogicOp', {
    'AND': partial(lambda l, r: l and r),
    'OR':  partial(lambda l, r: l or r)
})
```

### Особенности

1. **Значения членов**: Значения в `Enum` могут быть любыми — числами, строками, кортежами и даже функциями (если они обернуты).
2. **Имя члена**: Каждое имя члена автоматически становится атрибутом перечисления.
3. **Автоматическое значение**: Функция `auto()` автоматически присваивает значение члену перечисления, начиная с 1, если не указано другое.

### Пример использования

```python
from enum import Enum, auto

# Определяем Enum
class Cutlery(Enum):
    FORK = auto()
    KNIFE = auto()
    SPOON = auto()

# Доступ к членам
print(Cutlery.FORK)   # Cutlery.FORK
print(Cutlery['SPOON'])  # Cutlery.SPOON

# Получение значения и имени
print(Cutlery.FORK.name)  # 'FORK'
print(Cutlery.FORK.value)  # 1

# Перебор членов
for item in Cutlery:
    print(item.name, item.value)
```


## Исключения

Исключения в Python позволяют обработать ошибки, которые могут возникнуть во время выполнения программы. Для обработки ошибок используется конструкция `try...except`, которая позволяет перехватывать и обрабатывать исключения.

### Базовая структура

```python
try:
    # Код, который может вызвать исключение
except <exception>:
    # Код обработки исключения
```

### Сложный пример

```python
try:
    # Попытка выполнить код, который может вызвать исключение
    <code_1>
except <exception_a>:
    # Обработка исключения типа <exception_a>
    <code_2_a>
except <exception_b>:
    # Обработка исключения типа <exception_b>
    <code_2_b>
else:
    # Код, который выполнится, если исключений не было
    <code_2_c>
finally:
    # Код, который выполнится всегда (независимо от наличия исключений)
    <code_3>
```

- **`else`**: Код в этом блоке выполняется только если не произошло исключений в блоке `try`.
- **`finally`**: Код в этом блоке выполняется всегда, независимо от того, было ли исключение в `try`. Это полезно для освобождения ресурсов.
- **Область видимости переменных**: Переменные, созданные внутри блоков `try`, `except`, `else` или `finally`, доступны и за пределами этих блоков (в пределах их области действия).

### Перехват исключений

Вы можете перехватывать конкретные исключения или несколько исключений одновременно:

```python
# Перехват конкретного исключения
except <exception>: ...

# Перехват исключения с присваиванием переменной
except <exception> as <name>: ...

# Перехват нескольких исключений
except (<exception>, [...]): ...

# Перехват нескольких исключений с присваиванием
except (<exception>, [...]) as <name>: ...
```

- **Подклассы исключений**: Перехватчик исключений также будет ловить исключения, которые являются подклассами указанного типа.
- Для вывода подробной информации об исключении используйте `traceback.print_exc()` или другие методы.

### Работа с исключениями

- **Вывод причины исключения**:
    
    ```python
    print(<name>)  # Выводит только текст причины исключения
    ```
    
- **Логирование исключения**:
    
    ```python
    import logging
    logging.exception(<str>)  # Логирует сообщение вместе с трассировкой исключения
    ```
    
- **Получение информации об исключении**:
    
    ```python
    import sys
    exc_type, exc_value, exc_tb = sys.exc_info()
    ```
    

### Создание исключений

Вы можете генерировать исключения с помощью ключевого слова `raise`:

```python
raise <exception>  # Генерация исключения
raise <exception>()  # Генерация исключения с дополнительной информацией
raise <exception>(<obj>, ...)  # Генерация исключения с дополнительными аргументами
```

### Повторный вызов пойманного исключения

Если нужно повторно вызвать пойманное исключение в блоке `except`:

```python
except <exception> [as <name>]:
    # Код обработки исключения
    raise  # Повторный вызов исключения
```

### Объект-исключение

Каждое исключение — это объект с атрибутами, которые содержат информацию о его происхождении:

```python
arguments = <name>.args  # Аргументы исключения
exc_type  = <name>.__class__  # Тип исключения
filename  = <name>.__traceback__.tb_frame.f_code.co_filename  # Имя файла
func_name = <name>.__traceback__.tb_frame.f_code.co_name  # Имя функции
line      = linecache.getline(filename, <name>.__traceback__.tb_lineno)  # Строка ошибки
trace_str = ''.join(traceback.format_tb(<name>.__traceback__))  # Форматированный вывод трассировки
error_msg = ''.join(traceback.format_exception(type(<name>), <name>, <name>.__traceback__))  # Полное сообщение об ошибке
```

### Встроенные исключения

Python имеет встроенные классы исключений, некоторые из них:

```text
BaseException
 +-- SystemExit                   # Вызывается функцией sys.exit().
 +-- KeyboardInterrupt            # Возникает при нажатии ctrl-c.
 +-- Exception                    # Базовый класс для пользовательских исключений.
      +-- ArithmeticError         # Базовый класс для арифметических ошибок (например, ZeroDivisionError).
      +-- AssertionError          # Вызывается, когда выражение assert возвращает ложь.
      +-- AttributeError          # Возникает, если объект не имеет запрашиваемого атрибута.
      +-- EOFError                # Вызывается при достижении конца файла в input().
      +-- LookupError             # Базовый класс для ошибок поиска в коллекциях.
      |    +-- IndexError         # Ошибка при выходе индекса за пределы последовательности.
      |    +-- KeyError           # Ошибка, когда ключ не найден в словаре.
      +-- MemoryError             # Ошибка памяти.
      +-- NameError               # Возникает, если используется неопределенное имя.
      |    +-- UnboundLocalError  # Ошибка использования локальной переменной до ее присваивания.
      +-- OSError                 # Ошибки операционной системы (например, FileExistsError).
      |    +-- ConnectionError    # Ошибки сетевых соединений.
      +-- RuntimeError            # Ошибки выполнения.
      |    +-- NotImplementedError  # Ошибка, когда метод не реализован.
      |    +-- RecursionError     # Ошибка переполнения стека из-за рекурсии.
      +-- StopIteration           # Ошибка при использовании пустого итератора.
      +-- TypeError               # Ошибка при передаче неправильного типа данных.
      +-- ValueError              # Ошибка при передаче некорректного значения.
```

### Исключения для коллекций

В Python коллекции (списки, множества, словари) могут вызывать разные исключения:

|Операция|Список (List)|Множество (Set)|Словарь (Dict)|
|---|---|---|---|
|`getitem()`|`IndexError`||`KeyError`|
|`pop()`|`IndexError`|`KeyError`|`KeyError`|
|`remove()`|`ValueError`|`KeyError`||
|`index()`|`ValueError`|||

### Полезные встроенные исключения

Примеры полезных исключений:

```python
raise TypeError('Аргумент неправильного типа!')
raise ValueError('Аргумент имеет правильный тип, но недопустимое значение!')
raise RuntimeError('Мне лень определять свое собственное исключение!')
```

### Пользовательские исключения

Вы можете создать свои собственные классы исключений, наследуя от `Exception`:

```python
class MyError(Exception): pass
class MyInputError(MyError): pass
```

# Система
## Exit

**Завершает работу интерпретатора, вызвав исключение `SystemExit`.**

```python
import sys
sys.exit()                        # Выход с кодом 0 (успех).
sys.exit(<int>)                   # Выход с переданным кодом выхода.
sys.exit(<obj>)                   # Печать объекта в stderr и выход с кодом 1.
```

- **`sys.exit()`** вызывает выход с кодом 0, что обычно указывает на успешное завершение программы.
- **`sys.exit(<int>)`** позволяет передать код выхода, где 0 обычно обозначает успешное завершение, а любое ненулевое значение — ошибку или специфический статус.
- **`sys.exit(<obj>)`** печатает строковое представление объекта в `stderr` и завершает программу с кодом 1 (стандартный код ошибки).

## Print

```python
print(<el_1>, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
```

- **`sep`** — строка, которая будет вставлена между всеми выводимыми элементами. По умолчанию пробел `' '`.
- **`end`** — строка, которая будет добавлена в конце вывода. По умолчанию символ новой строки `'\n'`.
- **`file`** — поток, куда будет отправлен вывод. По умолчанию это `sys.stdout`, но можно использовать `sys.stderr` для вывода сообщений об ошибках.
- **`flush`** — если установлено в `True`, то буфер будет очищен сразу после вывода, иначе очистка буфера произойдёт, когда он будет переполнен или программа завершится.

_Пример использования для ошибок:_

```python
import sys
print("Ошибка произошла", file=sys.stderr)
```

---

## Pretty Print

```python
from pprint import pprint
pprint(<collection>, width=80, depth=None, compact=False, sort_dicts=True)
```

- **`width`** — максимальная длина строки, после которой будет произведен перенос на новую строку.
- **`depth`** — максимальная глубина вложенности, до которой будут распечатаны элементы коллекции. Если глубже — будет выведено `'...'`.
- **`compact`** — если установлено в `True`, то вывод будет более компактным.
- **`sort_dicts`** — если `True`, словари будут выводиться отсортированными по ключам.

---
## Input

```python
<str> = input(prompt=None)
```

- **`prompt`** — строка, которая будет выведена перед тем, как пользователь введет данные. Если не указана, то ничего выводиться не будет.
- **Возвращаемое значение** — строка, введенная пользователем, после того как он нажмет Enter (т.е. без символа новой строки).
- **EOFError** — ошибка, которая возникает, когда пользователь пытается ввести данные, но поток ввода закончился (например, при нажатии **Ctrl+D** или **Ctrl+Z**).

_Пример:_

```python
name = input("Введите ваше имя: ")
print(f"Привет, {name}!")
```

Если программа получает ввод через **pipe** или файл, то будет прочитана строка, в том числе и данные из этих источников, с теми же особенностями.

_Пример использования EOFError:_

```python
try:
    user_input = input("Введите данные: ")
except EOFError:
    print("Ввод завершен!")
```

Этот код обработает ситуацию, когда пользователь завершает ввод с помощью **Ctrl+D** (EOF).

## Command Line Arguments

Для работы с аргументами командной строки в Python используется модуль `sys`. Этот модуль предоставляет доступ к списку `sys.argv`, который содержит все аргументы, переданные скрипту.

#### Пример использования `sys.argv`:

```python
import sys

scripts_path = sys.argv[0]  # Путь к исполнимаемому скрипту
arguments = sys.argv[1:]    # Список всех аргументов, переданных скрипту (кроме пути)
```

- **`sys.argv`** — это список строк, где:
    
    - **`sys.argv[0]`** — путь к самому скрипту.
    - **`sys.argv[1:]`** — все остальные переданные аргументы.
    
    **Пример вызова скрипта:**
    
    Если запустить скрипт так:
    
    ```bash
    python script.py arg1 arg2
    ```
    
    то `sys.argv` будет выглядеть следующим образом:
    
    ```python
    ['script.py', 'arg1', 'arg2']
    ```
    

---

## Argument Parser

Для более сложной обработки аргументов командной строки рекомендуется использовать модуль `argparse`. Этот модуль предоставляет удобный способ добавления, парсинга и работы с аргументами командной строки, включая автоматическую генерацию помощи и проверку правильности ввода.

#### Основные шаги работы с `argparse`:

1. **Создание объекта парсера:**
    
    ```python
    from argparse import ArgumentParser
    
    p = ArgumentParser(description="Описание программы или её назначения")
    ```
    
    - **`description`** — описание программы, которое будет выведено при запросе помощи.
2. **Добавление аргументов:**
    
    ```python
    p.add_argument('<name>', <parameters>)
    ```
    
    Здесь `<name>` — это имя аргумента, а `<parameters>` — параметры, такие как тип данных, действия, количество значений и другие.
    

#### Пример добавления аргументов:

```python
p.add_argument('-v', '--verbose', action='store_true', help="Выводить подробную информацию.")
p.add_argument('input_file', type=str, help="Входной файл для обработки.")
p.add_argument('output_file', type=str, help="Выходной файл для сохранения.")
p.add_argument('--count', type=int, default=10, help="Количество итераций (по умолчанию 10).")
```

- **`action='store_true'`** — если этот флаг указан, то его значение будет `True`. Если флаг не указан — значение будет `False`.
- **`type=<type>`** — указывает тип данных для аргумента.
- **`help=<str>`** — описание аргумента, которое будет выведено при запросе помощи (`-h`).
- **`default=<obj>`** — значение по умолчанию для опциональных аргументов.
- **`nargs`** — количество значений, которые принимает аргумент:
    - **`'?'`** — один аргумент, необязательный.
    - **`'+'`** — один или более аргументов.
    - **`'*'`** — ноль или более аргументов.
    - **`1`** — строго один обязательный аргумент.

#### Пример парсинга и получения значений:

```python
args = p.parse_args()  # Парсит аргументы командной строки
input_file = args.input_file  # Получаем значение аргумента input_file
output_file = args.output_file  # Получаем значение аргумента output_file
count = args.count  # Получаем значение аргумента count
```

---

### Дополнительные параметры аргументов

- **`help`** — строка с описанием, которая будет отображена в случае запроса помощи.
- **`default`** — устанавливает значение по умолчанию для опциональных аргументов.
- **`type=FileType(<mode>)`** — позволяет работать с файлами. `<mode>` может быть:
    - `'r'` — для чтения файла.
    - `'w'` — для записи в файл.
    - `encoding` — задаёт кодировку, если необходимо.

Пример использования:

```python
from argparse import FileType

p.add_argument('-f', '--file', type=FileType('r'), help="Чтение из файла")
args = p.parse_args()
file_content = args.file.read()  # Чтение содержимого файла
```

---

### Пример полного использования `argparse`

```python
from argparse import ArgumentParser

# Создаем парсер
p = ArgumentParser(description="Пример работы с аргументами командной строки.")

# Добавляем аргументы
p.add_argument('-v', '--verbose', action='store_true', help="Выводить подробную информацию.")
p.add_argument('input_file', type=str, help="Входной файл для обработки.")
p.add_argument('output_file', type=str, help="Выходной файл для сохранения.")
p.add_argument('--count', type=int, default=10, help="Количество итераций (по умолчанию 10).")

# Парсим аргументы
args = p.parse_args()

# Пример использования аргументов
if args.verbose:
    print(f"Чтение из {args.input_file} и запись в {args.output_file}.")
print(f"Итерации: {args.count}")
```

#### Запуск:

```bash
python script.py input.txt output.txt --count 5
```

#### Вывод:

```bash
Итерации: 5
```

#### Пример с флагом:

Если указать флаг `--verbose`:

```bash
python script.py input.txt output.txt --count 5 --verbose
```

Результат будет:

```bash
Чтение из input.txt и запись в output.txt.
Итерации: 5
```

---

### Работа с аргументами командной строки с помощью `argparse` позволяет:

- Легко и удобно обрабатывать как обязательные, так и опциональные аргументы.
- Автоматически генерировать сообщение о помощи.
- Предоставлять пользователю удобный интерфейс для работы с параметрами скрипта.
## Открытие файла в Python

Для работы с файлами в Python используется функция `open`, которая возвращает объект файла. Она позволяет работать с файлами в различных режимах и настраивать параметры открытия.

```python
<file> = open(<path>, mode='r', encoding=None, newline=None)
```

- **`<path>`** — путь к файлу, который нужно открыть.
- **`mode`** — режим открытия файла (например, `'r'`, `'w'` и т.д.).
- **`encoding=None`** — кодировка для чтения или записи. По умолчанию используется кодировка, соответствующая платформе, но рекомендуется всегда указывать `encoding='utf-8'` для совместимости.
- **`newline=None`** — параметр для контроля обработки символов новой строки. Возможные значения:
    - **`None`** — все типы символов новой строки (например, `\n`, `\r\n`) преобразуются в `\n`.
    - **`""`** — отключает преобразования, оставляя символы новой строки в исходном виде.

---

### Режимы открытия файлов

1. **`'r'`** — Чтение. Открывает файл для чтения. Если файл не существует, выбрасывается исключение `FileNotFoundError`.
2. **`'w'`** — Запись. Открывает файл для записи, удаляя все данные. Если файл не существует, он будет создан.
3. **`'x'`** — Запись или ошибка, если файл уже существует.
4. **`'a'`** — Дописать. Открывает файл для записи в конец, не удаляя старые данные. Если файл не существует, он будет создан.
5. **`'w+'`** — Чтение и запись. Если файл существует, его содержимое будет удалено.
6. **`'r+'`** — Чтение и запись с начала файла.
7. **`'a+'`** — Чтение и запись с конца файла.
8. **`'b'`** — Бинарный режим. Например, `'rb'`, `'wb'`, `'xb'`.

---

### Исключения при открытии файла

- **`FileNotFoundError`** — возникает, если файл не существует при попытке открыть его в режиме `'r'` или `'r+'`.
- **`FileExistsError`** — возникает, если файл уже существует, а используется режим `'x'`.
- **`IsADirectoryError`** и **`PermissionError`** — могут возникнуть, если путь указывает на директорию или если нет прав на открытие файла.
- **`OSError`** — родительский класс для всех ошибок открытия файлов.

---

### Операции с файлом

Объект файла предоставляет несколько полезных методов для манипуляций с содержимым:

- **`seek(offset, whence=0)`** — перемещает курсор в указанное положение.
    
    - **`offset`** — смещение (в байтах).
    - **`whence`** — способ интерпретации смещения:
        - **`0`** — от начала файла (по умолчанию).
        - **`1`** — от текущей позиции.
        - **`2`** — от конца файла.
    
    Примеры:
    
    ```python
    file.seek(0)     # Перемещает курсор в начало файла
    file.seek(0, 2)  # Перемещает курсор в конец файла
    ```
    

#### Чтение данных из файла

- **`read(size=-1)`** — читает до `size` байтов (по умолчанию до конца файла).
- **`readline()`** — читает одну строку.
- **`readlines()`** — читает все строки и возвращает их в виде списка.
- **`next(file)`** — возвращает следующую строку с использованием буфера.

#### Запись данных в файл

- **`write(data)`** — записывает строку или байтовый объект.
- **`writelines(lines)`** — записывает коллекцию строк или байтовых объектов.
- **`flush()`** — очищает буфер записи, обеспечивая немедленную запись в файл.
- **`close()`** — закрывает файл после завершения работы с ним.

Примечание: методы **`write()`** и **`writelines()`** не добавляют символы новой строки, если их нет в данных.

---

### Примеры чтения и записи файлов

#### Чтение текста из файла:

```python
def read_file(filename):
    with open(filename, encoding='utf-8') as file:
        return file.readlines()  # Читает все строки в список
```

В этом примере используется контекстный менеджер `with`, который автоматически закроет файл после завершения работы.

#### Запись текста в файл:

```python
def write_to_file(filename, text):
    with open(filename, 'w', encoding='utf-8') as file:
        file.write(text)  # Записывает текст в файл
```

В этом примере также используется контекстный менеджер для безопасного открытия и закрытия файла.

---

### Примечания

- **Контекстный менеджер `with`** — это рекомендованный способ работы с файлами, так как он автоматически закрывает файл после завершения операций, даже если произошла ошибка в процессе работы.
- В случае работы с бинарными файлами используйте режимы типа `'rb'` или `'wb'`, а также учитывайте, что данные должны быть в байтовом формате (`bytes`), а не строках (`str`).

## Работа с Путями

Python предоставляет несколько модулей для работы с путями файлов, такими как `os`, `glob` и `pathlib`. Эти модули позволяют вам взаимодействовать с директориями и файлами, манипулировать путями и проверять свойства файлов.

---

### Модуль `os`

Модуль `os` предоставляет функции для взаимодействия с операционной системой, включая манипуляции с путями.

#### Получение Текущей Рабочей Директории

```python
str = os.getcwd()  # Возвращает текущую рабочую директорию.
```

#### Объединение Путей

```python
str = os.path.join(<path>, ...)  # Объединяет два или более компонента пути.
```

#### Разрешение Символических Ссылок

```python
str = os.path.realpath(<path>)  # Разрешает символические ссылки и возвращает абсолютный путь.
```

#### Извлечение Компонентов Пути

```python
str = os.path.basename(<path>)  # Возвращает последний компонент пути (например, имя файла).
str = os.path.dirname(<path>)   # Возвращает путь без последнего компонента.
tuple = os.path.splitext(<path>)  # Разделяет путь на имя и расширение.
```

#### Получение Списка Файлов в Директории

```python
list = os.listdir(path='.')  # Возвращает список файлов в указанной директории.
```

#### Использование Шаблонов для Поиска Путей

```python
list = glob.glob('<pattern>')  # Возвращает список путей, соответствующих шаблону.
```

#### Проверка Существования Файлов и Директорий

```python
bool = os.path.exists(<path>)  # Проверяет, существует ли путь.
bool = os.path.isfile(<path>)  # Проверяет, является ли путь файлом.
bool = os.path.isdir(<path>)   # Проверяет, является ли путь директорией.
```

#### Получение Статистики Файла

```python
stat = os.stat(<path>)  # Возвращает информацию о файле (например, размер, время изменения).
num = stat.st_mtime      # Время последнего изменения файла.
num = stat.st_size       # Размер файла в байтах.
```

### Использование `DirEntry`

В отличие от `os.listdir()`, метод `os.scandir()` возвращает объекты типа `DirEntry`, которые кешируют информацию о файле (например, является ли это файлом или директорией), что значительно ускоряет выполнение кода, если нужно выполнить несколько операций с файлами.

```python
iter = os.scandir(path='.')  # Возвращает объекты DirEntry в указанной директории.
str = dir_entry.path         # Возвращает полный путь к файлу или директории как строку.
str = dir_entry.name         # Возвращает последний компонент пути (например, имя файла).
file = open(dir_entry)       # Открывает файл и возвращает объект файла.
```

---

### Работа с объектом `Path` (модуль `pathlib`)

Модуль `pathlib` предлагает объектно-ориентированный интерфейс для работы с путями, который является более удобным и гибким.

#### Создание объекта `Path`

```python
Path = Path(<path> [, ...])  # Принимает строки, объекты Path или DirEntry.
```

#### Операции с путями

```python
Path = <path> / <path>  # Объединяет два пути, используя оператор '/'.
Path = <Path>.resolve()  # Возвращает абсолютный путь с разрешёнными символическими ссылками.
```

#### Получение Специальных Путей

```python
Path = Path()              # Возвращает относительный путь текущей рабочей директории (аналог os.getcwd()).
Path = Path.cwd()          # Возвращает абсолютный путь текущей рабочей директории.
Path = Path.home()         # Возвращает домашнюю директорию пользователя.
Path = Path(__file__).resolve()  # Возвращает путь к текущему скрипту, если рабочая директория не была изменена.
```

#### Извлечение Компонентов Пути

```python
Path = <Path>.parent        # Возвращает путь без последнего компонента.
str = <Path>.name           # Возвращает последний компонент пути как строку.
str = <Path>.stem           # Возвращает последний компонент пути без расширения.
str = <Path>.suffix         # Возвращает расширение последнего компонента пути.
tuple = <Path>.parts        # Возвращает все компоненты пути как кортеж строк.
```

#### Перебор Содержимого Директории

```python
iter = <Path>.iterdir()     # Возвращает содержимое директории как объекты Path.
```

#### Использование Шаблонов для Поиска Путей

```python
iter = <Path>.glob('<pattern>')  # Возвращает все пути, соответствующие шаблону.
```

#### Открытие Файлов

```python
str = str(<Path>)            # Преобразует объект Path в строку пути.
file = open(<Path>)          # Открывает файл по указанному пути и возвращает объект файла.
```

---

### Пример работы с путями

**Получение списка всех файлов в директории с определённым расширением:**

```python
from pathlib import Path

path = Path('/path/to/directory')
files = list(path.glob('*.txt'))  # Получение всех .txt файлов в директории
for file in files:
    print(file.name)
```

**Проверка существования файла и его размера:**

```python
from pathlib import Path

path = Path('example.txt')
if path.exists() and path.is_file():
    print(f"Размер файла: {path.stat().st_size} байт")
else:
    print("Файл не существует.")
```

---

Используя эти функции и методы, вы сможете эффективно работать с путями и файлами в Python, а также повысить производительность и удобство работы с файлами и директориями.

### Операции с Файловой Системой и Команды ОС

Python предоставляет несколько модулей для работы с операционной системой, таких как `os`, `shutil` и `subprocess`. Эти модули позволяют вам изменять текущую директорию, создавать, копировать, переименовывать и удалять файлы и каталоги, а также выполнять команды в оболочке.

---

### Модуль `os`

Модуль `os` предоставляет функции для взаимодействия с операционной системой.

#### Изменение Текущей Рабочей Директории

```python
os.chdir(<path>)  # Меняет текущую рабочую директорию на указанную.
```

#### Создание Директории

```python
os.mkdir(<path>, mode=0o777)      # Создаёт одну директорию с указанными правами (в октальном формате).
os.makedirs(<path>, mode=0o777)   # Создаёт все необходимые директории по пути, если их нет.
```

#### Копирование Файлов и Директорий

```python
shutil.copy(from, to)             # Копирует файл. 'to' может быть директорией или файлом.
shutil.copy2(from, to)            # Копирует файл с сохранением времени создания и модификации.
shutil.copytree(from, to)         # Копирует всю директорию. 'to' не должен существовать.
```

#### Переименование и Перемещение

```python
os.rename(from, to)               # Переименовывает или перемещает файл или директорию.
os.replace(from, to)              # То же самое, но перезаписывает 'to' даже на Windows.
shutil.move(from, to)             # Переименование с перемещением в другую директорию.
```

#### Удаление Файлов и Директорий

```python
os.remove(<path>)                 # Удаляет файл.
os.rmdir(<path>)                  # Удаляет пустую директорию.
shutil.rmtree(<path>)             # Удаляет директорию и все её содержимое.
```

- **Пути могут быть строками, объектами `Path` или `DirEntry`.**
- **Функции выбрасывают ошибки операционной системы через исключения `OSError` или его подклассы.**

---

### Работа с Командами Shell

Модуль `os` позволяет выполнять команды в оболочке, а `subprocess` предлагает более гибкие возможности для запуска процессов и взаимодействия с ними.

#### Выполнение Команд через Shell

```python
pipe = os.popen('<commands>')       # Выполняет команду в оболочке (sh или cmd), возвращает stdout.
str = pipe.read(size=-1)           # Читает вывод команды (до EOF или указанного размера).
int = pipe.close()                 # Закрывает поток и возвращает None, если команда завершилась успешно.
```

#### Пример: Ввод "1 + 1" в калькулятор и захват его вывода

```python
>>> subprocess.run('bc', input='1 + 1\n', capture_output=True, text=True)
CompletedProcess(args='bc', returncode=0, stdout='2\n', stderr='')
```

#### Пример: Передача файла `test.in` калькулятору и сохранение вывода в `test.out`

```python
>>> from shlex import split
>>> os.popen('echo 1 + 1 > test.in')
>>> subprocess.run(split('bc -s'), stdin=open('test.in'), stdout=open('test.out', 'w'))
CompletedProcess(args=['bc', '-s'], returncode=0)
>>> open('test.out').read()
'2\n'
```

---

### Пример работы с командами в оболочке

**Пример выполнения команды в оболочке и захват её вывода:**

```python
import subprocess

# Запуск команды и захват вывода
result = subprocess.run('ls', capture_output=True, text=True)
print(result.stdout)  # Печатает вывод команды ls
```

Этот код выполняет команду `ls` для отображения содержимого текущей директории и захватывает её вывод, чтобы затем вывести его в консоль.

# Данные
## Работа с JSON

**JSON (JavaScript Object Notation)** — это текстовый формат для хранения коллекций строк и чисел. Он используется для обмена данными между различными приложениями и системами.

В Python для работы с JSON используется модуль `json`, который предоставляет функции для преобразования объектов Python в JSON и обратно.

#### Основные операции с JSON

1. **Преобразование коллекции (списка или словаря) в JSON-строку**: Функция `json.dumps()` преобразует коллекцию в строку JSON.
    
    ```python
    import json
    str_data = json.dumps([1, 2, 3, 'text'])  # Преобразует список в строку JSON
    ```
    
2. **Преобразование JSON-строки обратно в коллекцию Python**: Функция `json.loads()` преобразует строку JSON в соответствующую коллекцию Python.
    
    ```python
    import json
    python_data = json.loads('{"name": "Alice", "age": 30}')  # Преобразует строку JSON в словарь
    ```
    

#### Чтение и запись JSON-данных из файла

1. **Чтение коллекции из JSON-файла**: Чтобы прочитать данные из JSON-файла и преобразовать их в Python-объект (например, список или словарь), используйте функцию `json.load()`.
    
    ```python
    def read_json_file(filename):
        with open(filename, encoding='utf-8') as file:
            return json.load(file)  # Загружает содержимое JSON-файла в Python-объект
    ```
    
2. **Запись коллекции в JSON-файл**: Чтобы сохранить коллекцию (список или словарь) в JSON-файл, используйте функцию `json.dump()`. Важно отметить, что параметр `ensure_ascii=False` позволяет сохранить символы, отличные от ASCII (например, русские буквы), а параметр `indent=2` делает вывод более читаемым, добавляя отступы в структуру.
    
    ```python
    def write_to_json_file(filename, list_or_dict):
        with open(filename, 'w', encoding='utf-8') as file:
            json.dump(list_or_dict, file, ensure_ascii=False, indent=2)  # Сохраняет объект в JSON-файл
    ```

## Работа с Pickle 

**Pickle** — это бинарный формат для хранения объектов Python. Он позволяет сериализовать (преобразовывать в байты) и десериализовать (восстанавливать из байтов) любые объекты Python, включая сложные структуры данных, такие как списки, словари, кортежи, пользовательские объекты и т.д.

#### Основные операции с Pickle

1. **Преобразование объекта Python в байтовый формат (сериализация)**: Функция `pickle.dumps()` используется для сериализации Python-объекта в поток байтов.
    
    ```python
    import pickle
    obj = {'name': 'Alice', 'age': 30}  # Пример объекта Python
    byte_data = pickle.dumps(obj)  # Преобразует объект в байты
    ```
    
2. **Преобразование байтового потока обратно в объект Python (десериализация)**: Функция `pickle.loads()` используется для десериализации байтового потока в оригинальный объект Python.
    
    ```python
    import pickle
    obj = pickle.loads(byte_data)  # Восстанавливает объект из байтов
    ```
    

#### Чтение и запись объектов с использованием Pickle

1. **Чтение объекта из файла**: Чтобы прочитать объект из бинарного файла, используйте функцию `pickle.load()`. Важно открыть файл в бинарном режиме (`'rb'`).
    
    ```python
    def read_pickle_file(filename):
        with open(filename, 'rb') as file:
            return pickle.load(file)  # Читает объект из файла
    ```
    
2. **Запись объекта в файл**: Чтобы сохранить объект в файл, используйте функцию `pickle.dump()`. Откройте файл в бинарном режиме (`'wb'`).
    
    ```python
    def write_to_pickle_file(filename, an_object):
        with open(filename, 'wb') as file:
            pickle.dump(an_object, file)  # Сохраняет объект в файл
    ```
    

**Примечание**: Pickle может не быть безопасным для загрузки данных, полученных из ненадежных источников, так как может быть использован для выполнения вредоносного кода. Поэтому всегда будьте осторожны при десериализации данных с помощью `pickle` из неизвестных источников.
## Работа с CSV

**CSV (Comma-Separated Values)** — это текстовый формат для хранения табличных данных, где каждая строка представляет собой запись, а значения внутри строки разделены запятыми (или другим разделителем). Этот формат часто используется для обмена данными между различными приложениями, такими как базы данных и электронные таблицы.

В Python для работы с CSV файлами используется стандартный модуль `csv`.

---

### Основные операции с CSV

#### 1. Чтение данных из CSV файла

Для чтения данных из CSV файла используется функция `csv.reader()`. Она принимает открытый файл или любой итератор строк, а затем преобразует строки в списки значений.

Пример чтения данных:

```python
import csv

with open('file.csv', newline='', encoding='utf-8') as file:
    reader = csv.reader(file)
    rows = list(reader)  # Преобразуем данные в список
    print(rows)
```

#### 2. Запись данных в CSV файл

Для записи данных в CSV файл используется функция `csv.writer()`. Она позволяет записывать строки в файл. Если файл уже существует, можно открыть его с режимом `'a'` для добавления новых строк, или с режимом `'w'` для перезаписи.

Пример записи данных:

```python
import csv

rows = [['name', 'age'], ['Alice', 30], ['Bob', 25]]
with open('output.csv', mode='w', newline='', encoding='utf-8') as file:
    writer = csv.writer(file)
    writer.writerows(rows)  # Запись нескольких строк
```

---

### Параметры для `csv.reader()` и `csv.writer()`

Для настройки поведения чтения и записи можно использовать несколько параметров:

- **`dialect`**: Задает значения по умолчанию для других параметров (например, `delimiter`, `quotechar` и т. д.). Это может быть строкой или объектом `csv.Dialect`.
- **`delimiter`**: Символ, который используется для разделения значений в строке (по умолчанию это запятая `,`).
- **`lineterminator`**: Определяет символ, который будет использоваться для завершения строк (например, `\n` или `\r\n`).
- **`quotechar`**: Символ, который используется для заключения значений, содержащих специальные символы (например, запятую или пробел).
- **`escapechar`**: Символ для экранирования символов кавычек внутри значений.
- **`quoting`**: Указывает, когда использовать кавычки вокруг значений:
    - `0`: Только если это необходимо.
    - `1`: Все значения заключаются в кавычки.
    - `2`: Все значения, кроме чисел (которые интерпретируются как числа с плавающей точкой).
    - `3`: Не использовать кавычки.
- **`skipinitialspace`**: Если установлено в `True`, пробелы в начале значений будут удаляться.

---

### Диалекты CSV

Диалекты задают стандартные параметры, такие как разделитель, символ кавычек и другие параметры, которые определяют формат CSV. Вот несколько распространенных диалектов:

|Параметр|**excel**|**excel-tab**|**unix**|
|---|---|---|---|
|**delimiter**|`,`|`\t`|`,`|
|**lineterminator**|`\r\n`|`\r\n`|`\n`|
|**quotechar**|`"`|`"`|`"`|
|**escapechar**|`None`|`None`|`None`|
|**doublequote**|`True`|`True`|`True`|
|**quoting**|`0`|`0`|`1`|
|**skipinitialspace**|`False`|`False`|`False`|

#### Пример использования диалекта:

```python
import csv

csv_params = {
    'dialect': 'excel',  # Диалект Excel (запятая как разделитель)
    'delimiter': ',',
    'quotechar': '"'
}

with open('file.csv', mode='w', newline='', encoding='utf-8') as file:
    writer = csv.writer(file, **csv_params)
    writer.writerow(['name', 'age'])
    writer.writerow(['Alice', 30])
    writer.writerow(['Bob', 25])
```

---

### Чтение строк из CSV файла

Для чтения строк из CSV файла, можно использовать следующую функцию, которая использует параметры для кастомизации чтения:

```python
import csv

def read_csv_file(filename, **csv_params):
    with open(filename, encoding='utf-8', newline='') as file:
        return list(csv.reader(file, **csv_params))
```

### Запись строк в CSV файл

Функция для записи строк в CSV файл с настройкой параметров записи:

```python
import csv

def write_to_csv_file(filename, rows, mode='w', **csv_params):
    with open(filename, mode, encoding='utf-8', newline='') as file:
        writer = csv.writer(file, **csv_params)
        writer.writerows(rows)
```

---

### Рекомендации по работе с CSV:

1. **Открытие файла**:
    
    - Открывайте файлы с аргументом `newline=''`, чтобы корректно обрабатывать символы новой строки в CSV. Это важно, чтобы избежать лишних символов на разных операционных системах.
2. **Использование диалектов**:
    
    - Если вы работаете с данными, которые могут быть сгенерированы в другом приложении (например, Excel), используйте диалект, соответствующий тому приложению, чтобы избежать ошибок при чтении и записи.
3. **Обработка кавычек и экранирования**:
    
    - Убедитесь, что правильно настраиваете `quotechar` и `escapechar`, чтобы предотвратить проблемы с символами в данных.
4. **Использование Pandas**:
    
    - Если данные в CSV файле сложные или содержат много различных типов, подумайте о использовании библиотеки [Pandas](https://pandas.pydata.org/), которая предоставляет более мощные инструменты для работы с табличными данными (например, поддерживает работу с Excel-файлами и сложными операциями).

---

Эти операции и параметры помогут вам эффективно работать с CSV данными, управляя форматами и структурой таблиц в Python.
## SQL
### SQLite
SQLite — это серверная база данных, которая хранит каждую базу данных в своем собственном файле. Она не требует установки сервера и идеально подходит для небольших приложений, где требуется легковесная и простая база данных.

---

#### Операции с SQLite

Для работы с SQLite в Python используется модуль `sqlite3`.

---

#### 1. Подключение к базе данных

Чтобы подключиться к базе данных SQLite, используйте `sqlite3.connect(<path>)`, где `<path>` — это путь к файлу базы данных. Если база данных не существует, она будет создана.

Пример:

```python
import sqlite3

# Подключаемся к базе данных (если файл базы данных не существует, он будет создан)
conn = sqlite3.connect('test.db')

# Закрываем соединение
conn.close()
```

---

#### 2. Чтение данных

Для выполнения запросов к базе данных используйте метод `execute()` и метод `fetchone()` или `fetchall()` для извлечения результатов.

Пример:

```python
import sqlite3

conn = sqlite3.connect('test.db')
cursor = conn.execute('SELECT * FROM person')

# Получение первой строки результата
row = cursor.fetchone()
print(row)

# Получение всех строк результата
rows = cursor.fetchall()
print(rows)

conn.close()
```

---

#### 3. Запись данных

Для внесения изменений в базу данных используйте метод `execute()`. После выполнения запросов, которые изменяют данные, необходимо вызвать метод `commit()` для сохранения изменений.

Пример:

```python
import sqlite3

conn = sqlite3.connect('test.db')

# Создание таблицы
conn.execute('CREATE TABLE person (person_id INTEGER PRIMARY KEY, name, height)')

# Вставка данных
conn.execute('INSERT INTO person VALUES (NULL, ?, ?)', ('Jean-Luc', 187))

# Сохранение изменений
conn.commit()

conn.close()
```

Если требуется отменить изменения, используйте метод `rollback()`.

---

#### 4. Запросы с параметрами (Placeholders)

SQLite поддерживает подстановку параметров в запросах, чтобы избежать SQL инъекций. Вместо того, чтобы вставлять значения непосредственно в SQL-запрос, можно использовать параметры с плейсхолдерами.

- Для обычных подстановок используется `?`:

```python
conn.execute('INSERT INTO person (name, height) VALUES (?, ?)', ('Alice', 170))
```

- Для именованных параметров используется `:key`:

```python
conn.execute('INSERT INTO person (name, height) VALUES (:name, :height)', {'name': 'Bob', 'height': 180})
```

- Для многократных вставок используется `executemany()`:

```python
data = [('Alice', 170), ('Bob', 180)]
conn.executemany('INSERT INTO person (name, height) VALUES (?, ?)', data)
```

---

#### 5. Пример использования

В этом примере создается таблица, добавляется строка и выполняется запрос для получения всех данных:

```python
import sqlite3

# Подключаемся к базе данных
conn = sqlite3.connect('test.db')

# Создание таблицы
conn.execute('CREATE TABLE person (person_id INTEGER PRIMARY KEY, name, height)')

# Вставка данных
conn.execute('INSERT INTO person VALUES (NULL, ?, ?)', ('Jean-Luc', 187))

# Получение данных
rows = conn.execute('SELECT * FROM person').fetchall()
print(rows)

# Сохранение изменений
conn.commit()

# Закрытие соединения
conn.close()
```

---

### SQLAlchemy

**SQLAlchemy** — это библиотека для работы с различными системами баз данных, которая поддерживает как SQL (через метод chaining), так и ORM (Object Relational Mapping). SQLAlchemy позволяет работать с базой данных через Python-объекты и запросы SQL.

Для установки SQLAlchemy:

```bash
$ pip3 install sqlalchemy
```

Пример использования SQLAlchemy для работы с SQLite:

```python
from sqlalchemy import create_engine, text

# Создание соединения с базой данных
engine = create_engine('sqlite:///test.db')  # URL для подключения

# Подключение и выполнение запросов
with engine.connect() as conn:
    result = conn.execute(text('SELECT * FROM person'))
    rows = result.fetchall()
    print(rows)
```

---

#### Таблица: Подключение к различным базам данных через SQLAlchemy

SQLAlchemy поддерживает различные диалекты для работы с базами данных. Для использования различных диалектов требуется установить соответствующие зависимости.

|Диалект|Установка через pip|Зависимости (пакеты)|
|---|---|---|
|**mysql**|`mysqlclient`|[mysqlclient](https://pypi.org/project/mysqlclient/)|
|**postgresql**|`psycopg2`|[psycopg2](https://pypi.org/project/psycopg2/)|
|**mssql**|`pyodbc`|[pyodbc](https://pypi.org/project/pyodbc/)|
|**oracle+oracledb**|`oracledb`|[oracledb](https://pypi.org/project/oracledb/)|

---


## Bytes

**Bytes** — это неизменяемая последовательность байтов. Для изменяемой версии используется `bytearray`.

---

#### Основные операции с объектами `bytes`

1. **Создание объекта bytes**
    
    - Используется литерал `b'<str>'`, который ограничен только ASCII-символами и байтами в диапазоне от `\x00` до `\xff`.
    
    ```python
    <bytes> = b'Hello'  # Пример байтовой строки.
    ```
    
2. **Доступ к байтам**
    
    - Вы можете получить отдельный байт, обращаясь к индексу или срезу:
    
    ```python
    byte = <bytes>[0]  # Возвращает байт как целое число (0-255).
    byte_range = <bytes>[1:4]  # Возвращает срез байтов.
    ```
    
3. **Объединение байтов**
    
    - Метод `join()` объединяет элементы в последовательности, вставляя в качестве разделителя строку байтов.
    
    ```python
    result = b' '.join([b'Hello', b'world'])
    print(result)  # b'Hello world'
    ```
    

---

#### Кодирование

1. **Создание объекта bytes из коллекции целых чисел**
    
    ```python
    byte_data = bytes([65, 66, 67])  # Преобразует список чисел в байты.
    ```
    
2. **Кодирование строки в байты**
    
    - Метод `encode()` или функция `bytes(<str>, 'utf-8')` используется для кодирования строки в байтовую строку.
    
    ```python
    byte_data = bytes('Hello', 'utf-8')  # Кодирует строку в байты.
    encoded_str = 'Hello'.encode('utf-8')  # Альтернативный способ.
    ```
    
3. **Создание байтов из шестнадцатеричной строки**
    
    - Метод `fromhex()` позволяет создать объект bytes из шестнадцатеричных значений.
    
    ```python
    byte_data = bytes.fromhex('68656c6c6f')  # Создает байты из шестнадцатеричной строки.
    ```
    
4. **Преобразование целого числа в байты**
    
    - Метод `to_bytes()` позволяет представить целое число как последовательность байтов.
    
    ```python
    byte_data = (12345).to_bytes(4, 'big')  # Преобразует число в байты (4 байта, big-endian).
    ```
    

---

#### Декодирование

1. **Конвертация байтов в список целых чисел**
    
    ```python
    byte_list = list(<bytes>)  # Преобразует байты в список целых чисел (0-255).
    ```
    
2. **Декодирование байтов в строку**
    
    - Используется метод `decode()` или функция `str(<bytes>, 'utf-8')` для преобразования байтов обратно в строку.
    
    ```python
    decoded_str = str(<bytes>, 'utf-8')  # Преобразует байты обратно в строку.
    decoded_str = <bytes>.decode('utf-8')  # Альтернативный способ.
    ```
    
3. **Преобразование байтов в шестнадцатеричную строку**
    
    - Метод `hex()` возвращает строку, представляющую байты в шестнадцатеричном формате.
    
    ```python
    hex_str = <bytes>.hex()  # Преобразует байты в строку в формате hex.
    ```
    
4. **Преобразование байтов в целое число**
    
    - Метод `int.from_bytes()` позволяет преобразовать байты в целое число.
    
    ```python
    number = int.from_bytes(<bytes>, 'big')  # Преобразует байты в число (big-endian).
    ```
    

---

#### Чтение и запись байтов в файлы

1. **Чтение байтов из файла**
    
    - Открывает файл в бинарном режиме и считывает его содержимое в байты.
    
    ```python
    def read_bytes(filename):
        with open(filename, 'rb') as file:
            return file.read()  # Возвращает все байты из файла.
    ```
    
2. **Запись байтов в файл**
    
    - Открывает файл в бинарном режиме и записывает байты.
    
    ```python
    def write_bytes(filename, bytes_obj):
        with open(filename, 'wb') as file:
            file.write(bytes_obj)  # Записывает байты в файл.
    ```
    

---

### Пример

```python
# Кодирование строки в байты
message = "Hello, world!"
byte_message = message.encode('utf-8')
print(byte_message)  # b'Hello, world!'

# Декодирование байтов в строку
decoded_message = byte_message.decode('utf-8')
print(decoded_message)  # Hello, world!

# Преобразование байтов в шестнадцатеричную строку
hex_message = byte_message.hex()
print(hex_message)  # 48656c6c6f2c20776f726c6421

# Преобразование числа в байты
number = 12345
byte_number = number.to_bytes(4, 'big')
print(byte_number)  # b'\x00\x00\x30\x39'

# Преобразование байтов в целое число
restored_number = int.from_bytes(byte_number, 'big')
print(restored_number)  # 12345
```

---


## Struct

------
### `struct` — Модуль для преобразования между последовательностью чисел и объектом байтов.

Модуль `struct` позволяет упаковывать (конвертировать) данные в байты и распаковывать их обратно в структуры Python, используя стандартные размеры типов данных системы, порядок байтов и правила выравнивания. Это полезно для работы с бинарными форматами, такими как файлы и сетевые протоколы.

#### Основные функции

1. **`pack(format, <el_1>, [...])`**
    
    - Упаковывает данные (например, числа) в объект `bytes` согласно формату, заданному строкой формата.
    - Пример:
    
    ```python
    from struct import pack
    packed_data = pack('<hhl', 1, 2, 3)
    print(packed_data)  # b'\x00\x01\x00\x02\x00\x00\x00\x03'
    ```
    
2. **`unpack(format, <bytes>)`**
    
    - Распаковывает данные из объекта `bytes` в исходные значения, возвращая кортеж.
    - Пример:
    
    ```python
    from struct import unpack
    unpacked_data = unpack('<hhl', b'\x00\x01\x00\x02\x00\x00\x00\x03')
    print(unpacked_data)  # (1, 2, 3)
    ```
    
3. **`iter_unpack(format, <bytes>)`**
    
    - Позволяет итерировать по распакованным данным, возвращая кортежи.

---

#### Форматы

1. **Порядок байтов:**
    
    - **`'='`** — системный порядок байтов (обычно little-endian).
    - **`'<'`** — little-endian (младший байт идет первым).
    - **`'>'`** — big-endian (старший байт идет первым).
    - **`'!'`** — big-endian (аналогично `'>'`).
2. **Типы данных:**
    
    - **`'b'`** — `char` (1 байт, знаковое число).
    - **`'B'`** — `unsigned char` (1 байт, без знака).
    - **`'h'`** — `short` (2 байта, знаковое число).
    - **`'H'`** — `unsigned short` (2 байта, без знака).
    - **`'i'`** — `int` (4 байта, знаковое число).
    - **`'I'`** — `unsigned int` (4 байта, без знака).
    - **`'l'`** — `long` (4 байта, знаковое число).
    - **`'L'`** — `unsigned long` (4 байта, без знака).
    - **`'q'`** — `long long` (8 байт, знаковое число).
    - **`'Q'`** — `unsigned long long` (8 байт, без знака).
    - **`'f'`** — `float` (4 байта).
    - **`'d'`** — `double` (8 байт).
3. **Символьные типы и байты:**
    
    - **`'c'`** — одиночный байт (строка длиной 1 символ).
    - **`'x'`** — пустой байт (для выравнивания).
    - **`'<n>s'`** — байтовый объект длины `n`.

---

#### Пример использования

```python
from struct import pack, unpack

# Упаковка данных
packed_data = pack('<hhl', 1, 2, 3)  # 1, 2, 3 упаковываются в байты
print(packed_data)  # b'\x00\x01\x00\x02\x00\x00\x00\x03'

# Распаковка данных
unpacked_data = unpack('<hhl', packed_data)
print(unpacked_data)  # (1, 2, 3)

# Пример упаковки с плавающей точкой
packed_float = pack('>d', 3.14159)
print(packed_float)  # b'\x40\x09\x21\xfb\x54\x44\x2d\x18'

# Распаковка плавающей точки
unpacked_float = unpack('>d', packed_float)
print(unpacked_float)  # (3.14159,)
```


## Array
-----
### `array` — Модуль для работы с массивами чисел фиксированного типа

Модуль `array` предоставляет способ хранения элементов одного типа (например, целых чисел или чисел с плавающей точкой) в памяти с эффективным использованием памяти, аналогично спискам, но с ограничениями по типу данных. Тип данных массива задается с помощью строкового кода (typecode), и каждый элемент массива имеет фиксированный размер.

#### Основные функции

1. **Создание массива из коллекции чисел:**
    
    ```python
    from array import array
    arr = array('<typecode>', <coll_of_nums>)  # Создает массив из последовательности чисел.
    ```
    
    - `<typecode>` — строковый код типа данных (например, `'i'` для целых чисел).
    - `<coll_of_nums>` — коллекция чисел, которую нужно преобразовать в массив.
2. **Создание массива из байтов:**
    
    ```python
    arr = array('<typecode>', <bytes>)  # Создает массив из байтовых данных.
    ```
    
    - `<bytes>` — объект байтов, который будет записан в память массива.
3. **Создание массива из другого массива:**
    
    ```python
    arr = array('<typecode>', <array>)  # Преобразует массив в новый массив.
    ```
    
4. **Чтение данных из файла в массив:**
    
    ```python
    arr.fromfile(<file>, n_items)  # Читает n_items элементов из бинарного файла в массив.
    ```
    

---

#### Преобразования между массивами и байтами

1. **Получение байтов из массива:**
    
    ```python
    <bytes> = bytes(<array>)  # Возвращает копию памяти массива как байтовый объект.
    ```
    
2. **Запись массива в бинарный файл:**
    
    ```python
    <file>.write(<array>)  # Записывает содержимое массива в файл.
    ```
    

---

#### Пример использования

```python
from array import array

# Создание массива целых чисел (int) в little-endian формате
arr = array('<i', [1, 2, 3, 4])
print(arr)  # array('i', [1, 2, 3, 4])

# Запись массива в байты
byte_data = bytes(arr)
print(byte_data)  # b'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00'

# Чтение данных из файла
with open('data.bin', 'wb') as file:
    arr.tofile(file)  # Записывает массив в файл

# Чтение массива из файла
with open('data.bin', 'rb') as file:
    new_arr = array('i')
    new_arr.fromfile(file, 4)  # Читает 4 целых числа
print(new_arr)  # array('i', [1, 2, 3, 4])
```

---

#### Методы массива

1. **`byteswap()`** — Метод для изменения порядка байтов каждого элемента (например, при изменении порядка байтов с little-endian на big-endian):
    
    ```python
    arr.byteswap()  # Меняет местами байты всех элементов массива.
    ```
    

---

#### Типы данных (typecodes)

Модуль `array` поддерживает следующие типы данных для элементов массива:

|Код|Тип|Размер (байт)|
|---|---|---|
|`'b'`|signed char|1|
|`'B'`|unsigned char|1|
|`'h'`|signed short|2|
|`'H'`|unsigned short|2|
|`'i'`|signed int|4|
|`'I'`|unsigned int|4|
|`'l'`|signed long|4|
|`'L'`|unsigned long|4|
|`'q'`|signed long long|8|
|`'Q'`|unsigned long long|8|
|`'f'`|float|4|
|`'d'`|double|8|

---

Модуль `array` полезен, когда необходимо эффективно хранить числовые данные в памяти и работать с ними, минимизируя использование ресурсов, особенно при обработке больших объемов данных.

## Memory View

**Memory view** — это объект, который предоставляет доступ к памяти других объектов (например, байтовых строк или массивов), без необходимости копировать данные. Это позволяет работать с большими объемами данных более эффективно. В отличие от обычных объектов, таких как байты или массивы, объект `memoryview` предоставляет способ доступа к данным в памяти, не копируя их, и позволяет изменять эти данные при необходимости.

#### Основные операции

1. **Создание memoryview:**
    
    ```python
    mview = memoryview(<bytes/bytearray/array>)  # Immutable, если передан bytes, иначе mutable.
    ```
    
    - `<bytes/bytearray/array>` — это объект, ссылающийся на данные (например, `bytes`, `bytearray`, `array`).
2. **Доступ к элементам:**
    
    ```python
    obj = mview[index]  # Возвращает int или float. Если формат 'c', возвращает байт.
    ```
    
    - При индексации возвращается один элемент, в зависимости от формата.
3. **Срезы:**
    
    ```python
    mview = mview[<slice>]  # Возвращает новый memoryview с измененным порядком элементов.
    ```
    
    - Можно использовать срезы, чтобы изменить порядок или выбрать часть данных.
4. **Преобразование типов (casting):**
    
    ```python
    mview = mview.cast('<typecode>')  # Преобразует memoryview в другой тип.
    ```
    
    - Применяется для преобразования между различными типами данных (например, из байтов в целые числа или числа с плавающей точкой).
5. **Освобождение буфера:**
    
    ```python
    mview.release()  # Освобождает буфер памяти, на который ссылается memoryview.
    ```
    

---

#### Преобразования между объектами

1. **Получение байтов из memoryview:**
    
    ```python
    bytes_data = bytes(mview)  # Возвращает новый объект bytes.
    byte_data = bytearray(mview)  # Возвращает новый объект bytearray.
    ```
    
2. **Объединение memoryview в один объект bytes:**
    
    ```python
    bytes_data = bytes.join(mview)  # Объединяет несколько memoryview в один объект bytes.
    ```
    
3. **Создание массива из memoryview:**
    
    ```python
    arr = array('<typecode>', mview)  # Создает массив на основе memoryview.
    ```
    
4. **Запись в файл:**
    
    ```python
    <file>.write(mview)  # Записывает байтовые данные из memoryview в бинарный файл.
    ```
    

---

#### Преобразования в другие типы

1. **Превращение memoryview в список:**
    
    ```python
    lst = list(mview)  # Возвращает список с элементами типа int, float или байтов.
    ```
    
2. **Преобразование в строку:**
    
    ```python
    str_data = str(mview, 'utf-8')  # Преобразует memoryview в строку, как байтовый объект.
    ```
    
3. **Получение шестнадцатеричной строки:**
    
    ```python
    hex_data = mview.hex()  # Возвращает строку, представляющую данные в шестнадцатеричном формате.
    ```
    

---

#### Пример использования

```python
# Создание memoryview для объекта bytes
data = b'Hello, World!'
mview = memoryview(data)

# Доступ к отдельным элементам
print(mview[0])  # 72 (ASCII код 'H')

# Преобразование memoryview в строку
str_data = str(mview, 'utf-8')
print(str_data)  # 'Hello, World!'

# Преобразование memoryview в список
list_data = list(mview)
print(list_data)  # [72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]

# Изменение типа данных memoryview
mview_cast = mview.cast('B')  # Преобразование в массив байтов
print(mview_cast)  # memoryview(b'Hello, World!')
```

---

### Форматы типов в memoryview

Типы данных, поддерживаемые в `memoryview`, могут включать в себя такие форматы, как:

- **`'B'`**: Беззнаковый байт (unsigned byte).
- **`'H'`**: Беззнаковое короткое целое (unsigned short).
- **`'i'`**: Целое число (signed int).
- **`'f'`**: Число с плавающей точкой (float).
- **`'d'`**: Число с плавающей точкой двойной точности (double).

Memoryview позволяет работать с этими типами данных, не копируя их, а лишь предоставляя доступ к существующим данным в памяти.

---

Использование `memoryview` эффективно при работе с большими объемами данных, когда важно избежать копирования данных и требуется манипулировать ими напрямую.
## Deque 

**Deque** (сокращение от "double-ended queue", Двухсторонняя очередь) — это структура данных, которая позволяет эффективно добавлять и удалять элементы с обоих концов (слева и справа). Она оптимизирована для работы с большими объемами данных, где важна высокая скорость вставки и удаления элементов с обоих концов очереди.

#### Основные операции

1. **Создание deque:**
    
    ```python
    from collections import deque
    
    my_deque = deque(<collection>)  # Создает deque из коллекции. Можно ограничить размер с помощью maxlen.
    ```
    
    - `<collection>` может быть списком, строкой, или любым другим итерируемым объектом.
2. **Добавление элемента в конец очереди:**
    
    ```python
    my_deque.append(<element>)  # Добавляет элемент в конец очереди.
    ```
    
3. **Добавление элемента в начало очереди:**
    
    ```python
    my_deque.appendleft(<element>)  # Добавляет элемент в начало очереди.
    ```
    
    - Если очереди достигнут максимального размера (если задан параметр `maxlen`), то элемент в другом конце будет удален.
4. **Удаление элемента с конца очереди:**
    
    ```python
    <el> = my_deque.pop()  # Удаляет и возвращает элемент с конца очереди.
    ```
    
5. **Удаление элемента с начала очереди:**
    
    ```python
    <el> = my_deque.popleft()  # Удаляет и возвращает элемент с начала очереди.
    # Raises IndexError если очередь пуста.
    ```
    
6. **Добавление нескольких элементов в начало очереди:**
    
    ```python
    my_deque.extendleft(<collection>)  # Добавляет коллекцию в начало очереди (коллекция будет перевернута).
    ```
    
7. **Циклический сдвиг очереди:**
    
    ```python
    my_deque.rotate(n=1)  # Сдвигает элементы на n позиций. Если n положительное, то сдвиг в сторону конца.
    ```
    
    - Когда элементы "переходят" с одного конца на другой, они автоматически становятся первыми или последними.

---

#### Пример использования:

```python
from collections import deque

# Создание deque из списка
d = deque([1, 2, 3])

# Добавление элемента в конец
d.append(4)  # deque([1, 2, 3, 4])

# Добавление элемента в начало
d.appendleft(0)  # deque([0, 1, 2, 3, 4])

# Удаление элемента с конца
last = d.pop()  # last = 4, deque([0, 1, 2, 3])

# Удаление элемента с начала
first = d.popleft()  # first = 0, deque([1, 2, 3])

# Циклический сдвиг
d.rotate(1)  # deque([3, 1, 2])

# Добавление нескольких элементов в начало
d.extendleft([4, 5])  # deque([5, 4, 3, 1, 2])

print(d)
```

**Результат:**

```
deque([5, 4, 3, 1, 2])
```

---

#### Параметры

- **`maxlen=<int>`**: Если задан максимальный размер (например, `maxlen=5`), то когда очередь достигает этого размера, добавление нового элемента будет автоматически удалять элемент с противоположной стороны (в зависимости от операции).

#### Примечания

- **Эффективность:** Операции добавления и удаления элементов с обеих сторон очереди (с помощью `append` и `popleft`) выполняются за время O(1), что делает `deque` значительно быстрее обычного списка при работе с большими объемами данных, когда операции добавления и удаления происходят с двух концов.

## Operator

Модуль `operator` в Python предоставляет функциональные аналоги большинства встроенных операторов. Эти функции позволяют использовать операторы как объекты высшего порядка, что полезно в таких случаях, как сортировка, фильтрация или другие операции, требующие передачи функции в качестве аргумента.

### Основные операции:

1. **Логические операторы:**
    
    ```python
    import operator as op
    
    op.not_(<obj>)  # Возвращает отрицание (not).
    op.eq(<obj1>, <obj2>)  # Проверяет на равенство (==).
    op.ne(<obj1>, <obj2>)  # Проверяет на неравенство (!=).
    op.lt(<obj1>, <obj2>)  # Проверяет на меньше (<).
    op.ge(<obj1>, <obj2>)  # Проверяет на больше или равно (>=).
    op.is_(<obj1>, <obj2>)  # Проверяет на идентичность (is).
    op.is_not(<obj1>, <obj2>)  # Проверяет на неидентичность (is not).
    op.contains(<obj1>, <obj2>)  # Проверяет, содержится ли объект в коллекции (in).
    ```
    
2. **Побитовые операторы:**
    
    ```python
    op.or_(<int1>, <int2>)   # Побитовое ИЛИ (|).
    op.xor(<int1>, <int2>)   # Побитовое исключающее ИЛИ (^).
    op.and_(<int1>, <int2>)  # Побитовое И (&).
    op.lshift(<int>, <shift>)  # Побитовый сдвиг влево (<<).
    op.rshift(<int>, <shift>) # Побитовый сдвиг вправо (>>).
    ```
    
3. **Арифметические операторы:**
    
    ```python
    op.add(<obj1>, <obj2>)    # Сложение (+).
    op.sub(<obj1>, <obj2>)    # Вычитание (-).
    op.mul(<obj1>, <obj2>)    # Умножение (*).
    op.truediv(<obj1>, <obj2>) # Деление (/).
    op.floordiv(<obj1>, <obj2>) # Целочисленное деление (//).
    op.mod(<obj1>, <obj2>)    # Остаток от деления (%).
    op.pow(<num1>, <num2>)    # Возведение в степень (**).
    ```
    
4. **Отрицание и инверсия:**
    
    ```python
    op.neg(<num>)  # Отрицание числа (-).
    op.invert(<num>)  # Побитовая инверсия (~).
    ```
    
5. **Генерация функций для работы с коллекциями:**
    
    ```python
    op.itemgetter(<index>)  # Создает функцию, которая получает элемент по индексу (или ключу для словарей).
    op.attrgetter(<attr>)   # Создает функцию для получения атрибута объекта.
    op.methodcaller(<method>, [args])  # Создает функцию для вызова метода объекта с передачей аргументов.
    ```
    

### Примеры использования:

1. **Сложение двух списков (поэлементно):**
    
    ```python
    list_a = [1, 2, 3]
    list_b = [4, 5, 6]
    elementwise_sum = map(op.add, list_a, list_b)
    print(list(elementwise_sum))  # [5, 7, 9]
    ```
    
2. **Сортировка списка по второму элементу в каждом кортедже:**
    
    ```python
    items = [(1, 'apple'), (2, 'banana'), (3, 'cherry')]
    sorted_by_second = sorted(items, key=op.itemgetter(1))
    print(sorted_by_second)  # [(1, 'apple'), (2, 'banana'), (3, 'cherry')]
    ```
    
3. **Вызов метода `pop` у списка:**
    
    ```python
    my_list = [10, 20, 30]
    first_element = op.methodcaller('pop', 0)(my_list)
    print(first_element)  # 10
    print(my_list)  # [20, 30]
    ```
    

#### Особенности:

- Операторы могут быть использованы как функции в тех случаях, когда необходимо передать их как аргументы другим функциям, например, при сортировке или фильтрации данных.
- Модуль `operator` позволяет использовать те же операторы Python в виде функций, что удобно для работы с функциональными подходами и в ситуациях, когда нужно передавать операторы как аргументы.

## Match 

`match` — это конструкция, позволяющая более выразительно работать с условными операциями, сравнивая объекты с различными шаблонами. Это своего рода улучшение над традиционным `if-elif`, основанное на паттерн-матчинге (сопоставление с образцом).

### Основной синтаксис:

```python
match <object/expression>:
    case <pattern> [if <condition>]:
        <code>
    ...
```

### Типы шаблонов:

1. **Значения (literal values):**
    
    ```python
    case 1:  # Сопоставляется с 1
        print("Found 1")
    case 'abc':  # Сопоставляется с строкой 'abc'
        print("Found 'abc'")
    case True:  # Сопоставляется с True
        print("Found True")
    case None:  # Сопоставляется с None
        print("Found None")
    ```
    
2. **Шаблон класса (тип):**
    
    ```python
    case int():  # Сопоставляется с любым объектом типа int
        print("It's an integer")
    ```
    
3. **Шаблон-переменная (capture pattern):**
    
    ```python
    case x:  # Присваивает объект переменной x
        print(f"Matched object: {x}")
    ```
    
4. **Шаблон с привязкой (as pattern):**
    
    ```python
    case [1, 2, 3] as seq:  # Привязывает список к переменной seq
        print(f"Matched sequence: {seq}")
    ```
    
5. **Шаблон с несколькими вариантами (or pattern):**
    
    ```python
    case 1 | 2 | 3:  # Сопоставляется с любым из вариантов
        print("Matched 1, 2, or 3")
    ```
    
6. **Шаблон последовательности (sequence pattern):**
    
    ```python
    case [1, 2, 3]:  # Сопоставляется с последовательностью [1, 2, 3]
        print("Matched sequence [1, 2, 3]")
    ```
    
7. **Шаблон отображения (mapping pattern):**
    
    ```python
    case {'key': value}:  # Сопоставляется с объектом, который является словарем
        print(f"Matched mapping with key: {value}")
    ```
    
8. **Шаблон с атрибутами класса:**
    
    ```python
    case Point(x=1, y=2):  # Сопоставляется с объектом типа Point, где x=1 и y=2
        print("Matched Point(1, 2)")
    ```
    
9. **Шаблон для связывания оставшихся элементов:**
    
    - В шаблонах последовательности:
        
        ```python
        case [1, 2, *rest]:  # Сопоставляется с первым двумя элементами и сохраняет оставшиеся в 'rest'
            print(f"Remaining items: {rest}")
        ```
        
    - В шаблонах отображения:
        
        ```python
        case {'key': value, **other}:  # Сохраняет остальные элементы в 'other'
            print(f"Other keys: {other}")
        ```
        

### Пример использования:

В следующем примере используется `match` для сопоставления с путем, который соответствует конкретной структуре:

```python
from pathlib import Path

# Пример с использованием match и шаблонов
match Path('/home/gto/python-cheatsheet/README.md'):
    case Path(
        parts=['/', 'home', user, *_]
    ) as p if p.name.lower().startswith('readme') and p.is_file():
        print(f'{p.name} is a readme file that belongs to user {user}.')
```

**Результат:**

```
README.md is a readme file that belongs to user gto.
```

В этом примере:

- Мы используем шаблон для сопоставления пути, который должен начинаться с `/home/` и содержать имя пользователя (`user`).
- Шаблон `*_*` захватывает остальные части пути, и условие проверяет, начинается ли имя файла с "readme" и является ли файл существующим.

## Logging
Модуль `logging` предоставляет мощные средства для записи сообщений о работе программы, что помогает отслеживать ошибки, состояния и различные события в процессе выполнения.

#### Основной синтаксис:

```python
import logging as log
```

```python
log.basicConfig(filename=<path>, level='DEBUG')  # Настройка основного логера.
log.debug/info/warning/error/critical(<str>)     # Запись сообщения в журнал.
<Logger> = log.getLogger(__name__)               # Получить логер для текущего модуля.
<Logger>.<level>(<str>)                          # Логирование через конкретный логер.
<Logger>.exception(<str>)                        # Запись ошибки с исключением.
```

#### Пример базовой настройки:

```python
log.basicConfig(
    filename=None,                                # Логирование в stderr или в файл.
    format='%(levelname)s:%(name)s:%(message)s',   # Формат записи (добавьте '%(asctime)s' для времени).
    level=log.WARNING,                            # Уровень логирования.
    handlers=[log.StreamHandler(sys.stderr)]      # Использует FileHandler, если указан путь к файлу.
)
```

#### Уровни логирования:

- **DEBUG**: Подробная информация, обычно используемая для отладки.
- **INFO**: Информация о нормальной работе программы.
- **WARNING**: Предупреждения о потенциальных проблемах.
- **ERROR**: Ошибки, которые могут вызвать проблемы, но программа может продолжить работу.
- **CRITICAL**: Серьезные ошибки, которые могут остановить программу.

#### Пример настройки обработчиков и форматтеров:

```python
# Создаем обработчик для записи логов в файл
<Formatter> = log.Formatter('<format>')           # Формат вывода.
<Handler> = log.FileHandler(<path>, mode='a')     # Обработчик для записи в файл.
<Handler>.setFormatter(<Formatter>)               # Применяем формат к обработчику.
<Handler>.setLevel(<int/str>)                     # Устанавливаем уровень логирования для обработчика.
<Logger>.addHandler(<Handler>)                    # Добавляем обработчик к логеру.
<Logger>.setLevel(<int/str>)                      # Устанавливаем уровень логирования для логера.
<Logger>.propagate = <bool>                       # Если False, не передаем сообщения родительским логерам.
```

#### Пример записи сообщений:

```python
# Получаем логер для текущего модуля
logger = log.getLogger('my_module')
handler = log.FileHandler('test.log', encoding='utf-8')
handler.setFormatter(log.Formatter('%(asctime)s %(levelname)s:%(name)s:%(message)s'))
logger.addHandler(handler)
logger.setLevel('DEBUG')

# Настройка корневого логера
log.basicConfig()
log.root.handlers[0].setLevel('WARNING')

# Логирование сообщений
logger.critical('Running out of disk space.')
# Вывод на экран: CRITICAL:my_module:Running out of disk space.
```

#### Фильтры:

Вы можете добавить фильтры для сообщений логирования. Например, добавление пользовательских фильтров позволяет исключать ненужные сообщения из журнала:

```python
class MyFilter:
    def filter(self, record):
        return 'important' in record.getMessage()

# Применение фильтра
handler.addFilter(MyFilter())
```

#### Пример с ротацией файлов:

Используйте `RotatingFileHandler`, чтобы создать лог-файл, который будет меняться по мере его заполнения:

```python
from logging.handlers import RotatingFileHandler

handler = RotatingFileHandler('app.log', maxBytes=2000, backupCount=5)
handler.setFormatter(log.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
log.getLogger().addHandler(handler)
log.setLevel(log.INFO)
```

Этот код создает ротацию файлов, где старые логи заменяются на новые, если размер файла превышает 2000 байт.

Логирование помогает эффективно отслеживать события, ошибки и поведение программы в реальном времени, а также помогает при отладке и поддержке приложения.

## Introspection 

Интроспекция позволяет динамически исследовать объекты, функции и их атрибуты, что полезно для отладки, генерации документации и работы с библиотеками, которые используют динамическое поведение.

### Основные функции:

```python
<list> = dir()                      # Возвращает список всех локальных имен (переменные, функции, классы, модули).
<dict> = vars()                     # Возвращает словарь локальных имен и их объектов. Аналогично locals().
<dict> = globals()                  # Возвращает словарь глобальных имен и их объектов, включая __builtin__.
```

### Интроспекция объектов:

```python
<list> = dir(<obj>)                 # Возвращает список атрибутов объекта (включая методы).
<dict> = vars(<obj>)                # Возвращает словарь атрибутов объекта, доступных для изменения. Также можно использовать <obj>.__dict__.
<bool> = hasattr(<obj>, '<name>')   # Проверяет, существует ли атрибут с данным именем у объекта.
value  = getattr(<obj>, '<name>')   # Получает атрибут объекта или вызывает исключение AttributeError, если атрибут отсутствует.
setattr(<obj>, '<name>', value)     # Устанавливает атрибут объекта. Работает только для объектов с атрибутом __dict__.
delattr(<obj>, '<name>')            # Удаляет атрибут из __dict__. Аналогично `del <obj>.<name>`.
```

### Пример работы с атрибутами:

```python
class Person:
    def __init__(self, name):
        self.name = name

p = Person('Alice')

# Получить список атрибутов
print(dir(p))

# Проверить наличие атрибута
print(hasattr(p, 'name'))  # True

# Получить значение атрибута
print(getattr(p, 'name'))  # 'Alice'

# Изменить значение атрибута
setattr(p, 'name', 'Bob')
print(p.name)  # 'Bob'

# Удалить атрибут
delattr(p, 'name')
print(hasattr(p, 'name'))  # False
```

### Интроспекция функций:

Используйте модуль `inspect` для работы с функциями и их параметрами.

```python
import inspect

<Sig>  = inspect.signature(<func>)  # Возвращает объект Signature функции.
<dict> = <Sig>.parameters           # Возвращает словарь параметров функции. Также можно получить return_annotation.
<memb> = <Param>.kind               # Возвращает тип параметра (например, Parameter.KEYWORD_ONLY).
<type> = <Param>.annotation         # Возвращает аннотацию типа параметра или Parameter.empty, если аннотация отсутствует.
```

Пример работы с `inspect`:

```python
def my_function(x: int, y: str = 'hello') -> bool:
    return str(x) == y

# Получить сигнатуру функции
sig = inspect.signature(my_function)

# Получить параметры функции
params = sig.parameters
print(params)  # OrderedDict([('x', <Parameter "x: int">), ('y', <Parameter "y: str = 'hello'">)])

# Получить аннотацию типа параметра
print(params['x'].annotation)  # <class 'int'>
```

Эти средства позволяют работать с атрибутами объектов и функциями в Python, что полезно для динамического анализа и манипуляции объектами во время выполнения программы.

## Threading
Интерпретатор CPython может одновременно выполнять только один поток, но многозадачность в Python полезна для выполнения операций ввода-вывода, таких как чтение/запись файлов или сетевые запросы, что может улучшить производительность в этих случаях.

### Основные классы и методы:

#### **Создание и управление потоками:**

```python
from threading import Thread

<Thread> = Thread(target=<function>)           # Поток, выполняющий функцию.
<Thread>.start()                               # Запускает поток.
<Thread>.join()                                # Ожидает завершения потока.
```

- Для передачи аргументов функции можно использовать `args=<tuple>` и `kwargs=<dict>`.
- Если установить `daemon=True`, поток будет завершаться, когда завершится основной процесс, иначе программа не завершится, пока потоки не завершат свою работу.

#### **Блокировки:**

```python
from threading import Lock, RLock

<lock> = Lock()                               # Простой lock.
<lock> = RLock()                              # RLock — рекурсивная блокировка (можно заблокировать несколько раз в одном потоке).
<lock>.acquire()                               # Ожидает, пока блокировка не будет доступна.
<lock>.release()                               # Освобождает блокировку.
```

Использование контекстного менеджера:

```python
with <lock>:                                   # Входит в блок, вызывая acquire(), и выходит с release(), даже при ошибке.
    ...
```

#### **Семафоры, События, Барьеры:**

```python
from threading import Semaphore, Event, Barrier

<Semaphore> = Semaphore(value=1)               # Семафор с возможностью блокировать только 'value' потоков.
<Event>     = Event()                          # Ожидает вызова set() для продолжения работы.
<Barrier>   = Barrier(n_times)                 # Блокирует выполнение до тех пор, пока не будет вызван n_times раз.
```

#### **Очереди:**

```python
from queue import Queue

<Queue> = Queue(maxsize=0)                     # Потокобезопасная очередь с возможностью блокировки.
<Queue>.put(<el>)                              # Блокирует выполнение до тех пор, пока очередь не станет не полной.
<Queue>.put_nowait(<el>)                       # Выбрасывает исключение queue.Full, если очередь полная.
<el> = <Queue>.get()                           # Блокирует выполнение до тех пор, пока очередь не станет непустой.
<el> = <Queue>.get_nowait()                    # Выбрасывает исключение queue.Empty, если очередь пустая.
```

#### **Пул потоков (Thread Pool Executor):**

```python
from concurrent.futures import ThreadPoolExecutor, as_completed

<Exec> = ThreadPoolExecutor(max_workers=None)  # Создает пул потоков. Если max_workers=None, то используется количество потоков по умолчанию.
<iter> = <Exec>.map(<func>, <args_1>, ...)     # Параллельное выполнение и сохранение порядка. Работает как map().
<Futr> = <Exec>.submit(<func>, <arg_1>, ...)   # Создает поток и возвращает объект Future.
<Exec>.shutdown()                              # Блокирует выполнение, пока все потоки не завершат выполнение.
```

- **Методы Future:**

```python
<bool> = <Future>.done()                       # Проверяет, завершен ли поток.
<obj>  = <Future>.result(timeout=None)         # Ждет завершения потока и возвращает результат.
<bool> = <Future>.cancel()                     # Отменяет выполнение потока (возвращает False, если поток уже завершен).
<iter> = as_completed(<coll_of_Futures>)       # Итератор, который возвращает завершенные потоки.
```

- **Использование `map()` и `as_completed()` с тайм-аутами:**
    - Если передать `timeout`, то будет вызвано исключение `futures.TimeoutError`, если выполнение будет блокироваться слишком долго.
    - Исключения, возникающие внутри потоков, можно обработать при вызове `result()` или во время итерации через `as_completed()`.

#### **Пример использования:**

```python
from concurrent.futures import ThreadPoolExecutor

def task(x):
    return x * x

with ThreadPoolExecutor(max_workers=3) as executor:
    futures = [executor.submit(task, i) for i in range(5)]
    for future in as_completed(futures):
        print(future.result())
```

В этом примере создается пул из трех потоков, и каждый поток выполняет функцию `task`, которая возводит число в квадрат.


## **Coroutines** 

**Коррутины** — это функции, которые могут приостанавливать и возобновлять свое выполнение, не блокируя выполнение других корутин. Они дают возможность управлять параллелизмом с меньшими затратами памяти по сравнению с потоками. Основное отличие корутин от потоков заключается в том, что коррутины приостанавливаются только тогда, когда они вызывают другую корутину (через `await`).

Чтобы создать корутину, используйте ключевое слово `async`, а для вызова — `await`.

### Основные методы и концепции:

#### **Определение и вызов корутин:**

```python
import asyncio as aio

async def <func_name>(<args>):
    # Код корутины
    return result

<result> = await <coroutine>  # Запуск корутины и ожидание ее результата.
<task> = aio.create_task(<coroutine>)  # Создание задачи, которая будет выполнена асинхронно.
<result> = await <task>       # Ожидание результата выполнения задачи.
```

#### **Группировка и управление несколькими корутинами:**

```python
<coro> = aio.gather(<coro/task>, ...)  # Запускает несколько корутин и возвращает их результаты.
<coro> = aio.wait(<tasks>, ...)        # Ожидает выполнения корутин до указанного состояния.
<iter> = aio.as_completed(<coros/tasks>)  # Итератор, возвращающий результаты завершенных корутин.
```

#### **Пример: Асинхронная игра в терминале**

Пример игры, где вы управлете астериском, который должен избегать столкновений с числами. Используется библиотека `asyncio` для асинхронного управления потоками действий.

```python
import asyncio, collections, curses, curses.textpad, enum, random

# Определение позиции и направления
P = collections.namedtuple('P', 'x y')
D = enum.Enum('D', 'n e s w')  # Направления

# Ширина и высота поля
W, H = 15, 7

def main(screen):
    curses.curs_set(0)  # Отключение курсора
    screen.nodelay(True)  # Неблокирующий режим для getch()
    asyncio.run(main_coroutine(screen))  # Запуск основной корутины

async def main_coroutine(screen):
    moves = asyncio.Queue()
    state = {'*': P(0, 0)} | {id_: P(W//2, H//2) for id_ in range(10)}
    ai = [random_controller(id_, moves) for id_ in range(10)]
    mvc = [human_controller(screen, moves), model(moves, state), view(state, screen)]
    tasks = [asyncio.create_task(coro) for coro in ai + mvc]
    await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)

async def random_controller(id_, moves):
    while True:
        d = random.choice(list(D))
        moves.put_nowait((id_, d))  # Отправка движения в очередь
        await asyncio.sleep(random.triangular(0.01, 0.65))  # Рандомная пауза

async def human_controller(screen, moves):
    while True:
        key_mappings = {258: D.s, 259: D.n, 260: D.w, 261: D.e}  # Сопоставление клавиш с направлениями
        if d := key_mappings.get(screen.getch()):
            moves.put_nowait(('*', d))  # Отправка движения астериска в очередь
        await asyncio.sleep(0.005)

async def model(moves, state):
    while state['*'] not in (state[id_] for id_ in range(10)):  # Проверка на столкновение
        id_, d = await moves.get()  # Получение следующего движения из очереди
        deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)}
        state[id_] = P((state[id_].x + deltas[d].x) % W, (state[id_].y + deltas[d].y) % H)

async def view(state, screen):
    offset = P(curses.COLS//2 - W//2, curses.LINES//2 - H//2)  # Смещение для отображения на экране
    while True:
        screen.erase()
        curses.textpad.rectangle(screen, offset.y-1, offset.x-1, offset.y+H, offset.x+W)  # Отображение рамки
        for id_, p in state.items():
            screen.addstr(offset.y + (p.y - state['*'].y + H//2) % H,
                          offset.x + (p.x - state['*'].x + W//2) % W, str(id_))  # Отображение объектов
        screen.refresh()
        await asyncio.sleep(0.005)

if __name__ == '__main__':
    curses.wrapper(main)
```

#### Объяснение:

- **`main_coroutine`**: Главная корутина, которая запускает другие корутины для обработки движений, логики и отображения.
- **`random_controller`**: Рандомный контроллер для "врагов", который случайным образом выбирает направление для движения.
- **`human_controller`**: Контроллер для пользователя, который управляет астериском с помощью клавиш.
- **`model`**: Моделирует движение объектов на поле.
- **`view`**: Отображает состояние игры на экране с использованием библиотеки `curses`.

#### **Ключевые моменты:**

- **`asyncio.run()`** используется для запуска главной асинхронной корутины.
- **`await`** позволяет корутинам приостанавливать выполнение, чтобы другие могли выполнить свои задачи, не блокируя программу.


# Библиотеки

## **Progress Bar** 

**`tqdm`** — это популярная библиотека для создания индикаторов выполнения (progress bars) в консоли или GUI. Она легко интегрируется с любыми итерациями и циклическими конструкциями, такими как `for` или генераторы.

### Установка:

```bash
$ pip3 install tqdm
```

### Пример использования:

```python
import tqdm
import time

# Используем tqdm для отслеживания прогресса итерации
for el in tqdm.tqdm([1, 2, 3], desc='Processing'):
    time.sleep(1)  # Эмуляция задержки
```

### Ожидаемый вывод:

```
Processing: 100%|████████████████████| 3/3 [00:03<00:00,  1.00s/it]
```

### Параметры `tqdm`:

- **`desc`**: Текстовое описание прогресса (например, `'Processing'`).
- **`total`**: Общее количество элементов в итерации (если оно неизвестно).
- **`ncols`**: Ширина для отображения прогресс-бара.
- **`ascii`**: Если установить в `True`, прогресс-бар будет отображаться с помощью символов ASCII.
- **`unit`**: Одиночная единица измерения (например, 'item', 'iteration').

`tqdm` можно использовать в различных случаях, например, для мониторинга работы долгих циклов или загрузок, и позволяет интегрировать прогресс-бар с другими библиотеками, такими как `pandas`, `numpy`, и т. д.

## Графики

**`matplotlib`** — это библиотека для создания графиков и визуализации данных в Python.

### Установка:

```bash
$ pip3 install matplotlib
```

### Основное использование:

```python
import matplotlib.pyplot as plt

# Пример линейного графика
x_data = [1, 2, 3, 4, 5]
y_data = [1, 4, 9, 16, 25]

plt.plot(x_data, y_data, label='y = x^2')  # Создание линейного графика
plt.legend()  # Добавление легенды
plt.title('Simple Plot')  # Заголовок графика
plt.xlabel('X values')    # Подпись оси X
plt.ylabel('Y values')    # Подпись оси Y
plt.show()  # Отображение графика
```

### Другие типы графиков:

```python
# Столбчатая диаграмма
plt.bar(x_data, y_data, label='Bar Chart')
plt.legend()
plt.show()

# Точечный график
plt.scatter(x_data, y_data, label='Scatter Plot')
plt.legend()
plt.show()
```

### Сохранение графика:

```python
# Сохранение графика в файл
plt.savefig('plot.png')
```

### Очистка графика:

```python
# Очистка текущего графика
plt.clf()
```

#### Примечания:

- **`plt.plot()`** — используется для линейных графиков.
- **`plt.bar()`** — для столбчатых диаграмм.
- **`plt.scatter()`** — для точечных графиков.
- **`plt.legend()`** — добавляет легенду на график.
- **`plt.savefig(<path>)`** — сохраняет график в файл.
- **`plt.show()`** — отображает график на экране.

**`matplotlib`** также поддерживает различные типы настроек, таких как цвет, стиль линий, маркеры и шрифты, а также можно настроить отображение нескольких графиков на одной оси.


## Table Display

**`tabulate`** — это библиотека для красивого вывода таблиц в консоль в различных форматах, таких как текстовый, Markdown или HTML.

### Установка:

```bash
$ pip3 install tabulate
```

### Пример использования с CSV-файлом:

```python
import csv
import tabulate

# Чтение CSV-файла и вывод его в виде таблицы
with open('test.csv', encoding='utf-8', newline='') as file:
    rows = list(csv.reader(file))  # Считываем все строки из CSV
    print(tabulate.tabulate(rows, headers='firstrow'))  # Выводим таблицу с первой строкой как заголовками
```

### Пример вывода:

```
+--------+---------+-------+
| Name   | Age     | City  |
+--------+---------+-------+
| Alice  | 24      | Paris |
| Bob    | 30      | London|
| Charlie| 22      | NY    |
+--------+---------+-------+
```

### Дополнительные параметры:

- **`headers='firstrow'`** — указывает, что первая строка CSV будет использоваться как заголовки.
- **`tablefmt`** — формат вывода таблицы, например: `'plain'`, `'grid'`, `'fancy_grid'`, `'pipe'`, `'html'`, и другие.

### Пример с выбором формата:

```python
print(tabulate.tabulate(rows, headers='firstrow', tablefmt='grid'))
```

**Примечания:**

- **`tabulate`** идеально подходит для вывода таблиц в консоль, особенно если данные имеют структуру в виде CSV или списков списков.

## Консольное приложение
-----------
### Небольшой консольный проводник:

```python
# $ pip3 install windows-curses
import curses, os
from curses import A_REVERSE, KEY_DOWN, KEY_UP, KEY_LEFT, KEY_RIGHT, KEY_ENTER

def main(screen):
    ch, first, selected, paths = 0, 0, 0, os.listdir()
    while ch != ord('q'):
        height, width = screen.getmaxyx()
        screen.erase()
        for y, filename in enumerate(paths[first : first+height]):
            color = A_REVERSE if filename == paths[selected] else 0
            screen.addnstr(y, 0, filename, width-1, color)
        ch = screen.getch()
        selected += (ch == KEY_DOWN) - (ch == KEY_UP)
        selected = max(0, min(len(paths)-1, selected))
        first += (selected >= first + height) - (selected < first)
        if ch in [KEY_LEFT, KEY_RIGHT, KEY_ENTER, ord('\n'), ord('\r')]:
            new_dir = '..' if ch == KEY_LEFT else paths[selected]
            if os.path.isdir(new_dir):
                os.chdir(new_dir)
                first, selected, paths = 0, 0, os.listdir()

if __name__ == '__main__':
    curses.wrapper(main)
```

### Описание:

Этот скрипт реализует простой проводник файлов в консоли с использованием библиотеки `curses`. Он отображает файлы и папки в текущем каталоге и позволяет:

1. Перемещаться по файлам с помощью стрелок вверх/вниз.
2. Переходить в родительскую папку с помощью стрелки влево.
3. Переходить в выбранную папку с помощью клавиши Enter.
4. Выходить из программы с помощью клавиши `q`.

Необходимо установить библиотеку `windows-curses` для работы на Windows.

## GUI-Приложение
-------
### Конвертация веса:


```python
# $ pip3 install PySimpleGUI
import PySimpleGUI as sg

text_box = sg.Input(default_text='100', enable_events=True, key='-QUANTITY-')
dropdown = sg.InputCombo(['g', 'kg', 't'], 'kg', readonly=True, enable_events=True, k='-UNIT-')
label    = sg.Text('100 кг это 220.462 фунтов.', key='-OUTPUT-')
button   = sg.Button('Закрыть')
window   = sg.Window('Конвертер веса', [[text_box, dropdown], [label], [button]])

while True:
    event, values = window.read()
    if event in [sg.WIN_CLOSED, 'Закрыть']:
        break
    try:
        quantity = float(values['-QUANTITY-'])
    except ValueError:
        continue
    unit = values['-UNIT-']
    factors = {'g': 0.001, 'kg': 1, 't': 1000}
    lbs = quantity * factors[unit] / 0.45359237
    window['-OUTPUT-'].update(value=f'{quantity} {unit} это {lbs:g} фунтов.')
window.close()
```

### Описание:

Этот скрипт создаёт графическое приложение для конвертации веса с использованием библиотеки `PySimpleGUI`. Пользователь вводит количество и выбирает единицу измерения (граммы, килограммы или тонны), после чего приложение выводит эквивалентное значение в фунтах. Программа реализует следующие функции:

1. **Ввод количества** — поле ввода для значения веса.
2. **Выбор единицы измерения** — выпадающий список с выбором единиц: граммы, килограммы или тонны.
3. **Вывод результата** — метка, которая обновляется с результатом перевода в фунты.
4. **Закрытие приложения** — кнопка для закрытия окна.

Необходимо установить библиотеку `PySimpleGUI` для работы графического интерфейса.



## Скрейпинг

### Beautiful Soup 4
#### Скачивает URL и логотип Python с его страницы на Википедии:

```python
# $ pip3 install requests beautifulsoup4
import requests, bs4, os

response   = requests.get('https://en.wikipedia.org/wiki/Python_(programming_language)')
document   = bs4.BeautifulSoup(response.text, 'html.parser')
table      = document.find('table', class_='infobox vevent')
python_url = table.find('th', text='Website').next_sibling.a['href']
logo_url   = table.find('img')['src']
logo       = requests.get(f'https:{logo_url}').content
filename   = os.path.basename(logo_url)
with open(filename, 'wb') as file:
    file.write(logo)
print(f'{python_url}, file://{os.path.abspath(filename)}')
```

### Selenium

**Библиотека для скрейпинга веб-сайтов с динамическим контентом.**

```python
# $ pip3 install selenium
from selenium import webdriver

<WebDrv> = webdriver.Chrome/Firefox/Safari/Edge()     # Открывает браузер. Также <WebDrv>.quit().
<WebDrv>.get('<url>')                                 # Также <WebDrv>.implicitly_wait(секунды).
<El>   = <WebDrv/El>.find_element('css selector', …)  # '<tag>#<id>.<class>[<attr>="<val>"]…'.
<list> = <WebDrv/El>.find_elements('xpath', …)        # '//<tag>[@<attr>="<val>"]…'. Смотрите XPath.
<str>  = <El>.get_attribute(<str>)                    # Свойство элемента. Также <El>.text.
<El>.click/clear()                                    # Также <El>.send_keys(<str>).
```

### XPath — также доступен в lxml, Scrapy и консоли браузера через `'$x("<xpath>")'`:

```python
<xpath>     = //<element>[/ или // <element>]          # /<child>, //<descendant>, /../<sibling>
<xpath>     = //<element>/following::<element>        # Следующий элемент. Также preceding/parent/…
<element>   = <tag><условия><индекс>                  # `<tag> = */a/…`, `<index> = [1/2/…]`.
<условие>   = [<sub_cond> [и/или <sub_cond>]]         # Для отрицания используйте `not(<sub_cond>)`.
<sub_cond>  = @<attr>[="<val>"]                       # `text()=`, `.=` для полного совпадения текста.
<sub_cond>  = contains(@<attr>, "<val>")              # Является ли <val> подстрокой значения атрибута?
<sub_cond>  = [//]<element>                           # Есть ли совпадающий дочерний элемент? Потомок, если //.
```


## Web-приложение

**Flask — это микро веб-фреймворк/сервер. Если нужно просто открыть HTML файл в веб-браузере, используйте `'webbrowser.open(<путь>)'` вместо этого.**

```python
# $ pip3 install flask
import flask as fl
```

```python
app = fl.Flask(__name__)                   # Возвращает объект приложения. Поместить в начало.
app.run(host=None, port=None, debug=None)  # Или: $ flask --app FILE run [--ARG[=VAL]]…
```

- **Запускает приложение по адресу `'http://localhost:5000'`. Для внешнего запуска используйте `'host="0.0.0.0"'`.**
- **Установите WSGI сервер, например, [Waitress](https://flask.palletsprojects.com/en/latest/deploying/waitress/), и HTTP сервер, например, [Nginx](https://flask.palletsprojects.com/en/latest/deploying/nginx/), для повышения безопасности.**
- **Режим отладки перезапускает приложение при изменении скрипта и отображает ошибки в браузере.**

### Статический запрос

```python
@app.route('/img/<path:filename>')
def serve_file(filename):
    return fl.send_from_directory('dirname/', filename)
```

### Динамический запрос

```python
@app.route('/<sport>')
def serve_html(sport):
    return fl.render_template_string('<h1>{{title}}</h1>', title=sport)
```

- **`'fl.render_template(filename, <kwargs>)'` рендерит файл, расположенный в директории 'templates'.**
- **`'fl.abort(<int>)'` возвращает код ошибки, а `'return fl.redirect(<url>)'` выполняет редирект.**
- **`'fl.request.args[<str>]'` возвращает параметр из строки запроса (часть URL после '?').**
- **`'fl.session[<str>] = <obj>'` сохраняет данные сессии. Для этого нужно установить секретный ключ при запуске с `'app.secret_key = <str>'`.**

### REST запрос

```python
@app.post('/<sport>/odds')
def serve_json(sport):
    team = fl.request.form['team']
    return {'team': team, 'odds': [2.09, 3.74, 3.68]}
```

#### Запускает приложение в отдельном потоке и выполняет запрос к его REST API:

```python
# $ pip3 install requests
>>> import threading, requests
>>> threading.Thread(target=app.run, daemon=True).start()
>>> url = 'http://localhost:5000/football/odds'
>>> response = requests.post(url, data={'team': 'arsenal f.c.'})
>>> response.json()
{'team': 'arsenal f.c.', 'odds': [2.09, 3.74, 3.68]}
```


## Профилирование

**Профилирование** — это процесс анализа выполнения программы с целью выявления узких мест в производительности, таких как медленные участки кода или высокое потребление памяти.
#### Измерение времени выполнения

```python
from time import perf_counter
start_time = perf_counter()
...
duration_in_seconds = perf_counter() - start_time
```

### Время выполнения фрагмента кода

```python
>>> from timeit import timeit
>>> timeit('list(range(10000))', number=1000, globals=globals(), setup='pass')
0.19373
```

### Профилирование по строкам

```text
$ pip3 install line_profiler
$ echo '@profile
def main():
    a = list(range(10000))
    b = set(range(10000))
main()' > test.py
$ kernprof -lv test.py
Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     1                                           @profile
     2                                           def main():
     3         1        253.4    253.4     32.2      a = list(range(10000))
     4         1        534.1    534.1     67.8      b = set(range(10000))
```

### Графики вызовов и Flame-графики

```bash
$ apt/brew install graphviz && pip3 install gprof2dot snakeviz  # Или скачайте установщик.
$ tail --lines=+2 test.py > test.py                             # Удаляет первую строку.
$ python3 -m cProfile -o test.prof test.py                      # Запускает встроенный профайлер.
$ gprof2dot --format=pstats test.prof | dot -T png -o test.png  # Генерирует граф вызовов.
$ xdg-open/open test.png                                        # Открывает граф вызовов.
$ snakeviz test.prof                                            # Открывает flame-график.
```


### Профилировщики для сэмплинга и памяти

|pip3 install|Цель|Как запустить|Строки|Жив. данные|
|---|---|---|---|---|
|pyinstrument|CPU|`pyinstrument test.py`|Нет|Нет|
|py-spy|CPU|`py-spy top -- python3 test.py`|Нет|Да|
|scalene|CPU + Память|`scalene test.py`|Да|Нет|
|memray|Память|`memray run --live test.py`|Да|Да|

## **NumPy**

**Мини-язык для манипуляций с массивами. Может быть в 100 раз быстрее эквивалентного кода на Python. Еще более быстрый аналог, работающий на GPU — CuPy.**

```python
# $ pip3 install numpy
import numpy as np
```

```python
<array> = np.array(<list/list_of_lists/…>)              # Возвращает одномерный/двумерный … массив NumPy.
<array> = np.zeros/ones/empty(<shape>)                  # Также np.full(<shape>, <el>).
<array> = np.arange(from_inc, to_exc, ±step)            # Также np.linspace(start, stop, len).
<array> = np.random.randint(from_inc, to_exc, <shape>)  # Также np.random.random(<shape>).
```

```python
<view>  = <array>.reshape(<shape>)                      # Также `<array>.shape = <shape>`.
<array> = <array>.flatten()                             # Также `<view> = <array>.ravel()`.
<view>  = <array>.transpose()                           # Или: <array>.T
```

```python
<array> = np.copy/abs/sqrt/log/int64(<array>)           # Возвращает новый массив с тем же размером.
<array> = <array>.sum/max/mean/argmax/all(axis)         # Агрегирует по указанному измерению.
<array> = np.apply_along_axis(<func>, axis, <array>)    # Func может вернуть как скаляр, так и массив.
```

```python
<array> = np.concatenate(<list_of_arrays>, axis=0)      # Склеивает массивы по первому измерению (строки).
<array> = np.vstack/column_stack(<list_of_arrays>)      # Рассматривает одномерные массивы как строки или столбцы.
<array> = np.tile/repeat(<array>, <int/list> [, axis])  # Повторяет массив или его элементы.
```

- **Shape — это кортеж с размерами измерений. RGB изображение 100x50 имеет форму (50, 100, 3).**
- **Axis — индекс измерения. Левое измерение имеет индекс 0. Суммирование RGB изображения по оси 2 даст изображение в оттенках серого с формой (50, 100).**

### Индексация

```perl
<el>       = <2d>[row_index, col_index]                 # Или: <3d>[<int>, <int>, <int>]
<1d_view>  = <2d>[row_index]                            # Или: <3d>[<int>, <int>, <slice>]
<1d_view>  = <2d>[:, col_index]                         # Или: <3d>[<int>, <slice>, <int>]
<2d_view>  = <2d>[from:to_row_i, from:to_col_i]         # Или: <3d>[<int>, <slice>, <slice>]
```

```perl
<1d_array> = <2d>[row_indices, col_indices]             # Или: <3d>[<int/1d>, <1d>, <1d>]
<2d_array> = <2d>[row_indices]                          # Или: <3d>[<int/1d>, <1d>, <slice>]
<2d_array> = <2d>[:, col_indices]                       # Или: <3d>[<int/1d>, <slice>, <1d>]
<2d_array> = <2d>[np.ix_(row_indices, col_indices)]     # Или: <3d>[<int/1d/2d>, <2d>, <2d>]
```

```perl
<2d_bools> = <2d> > <el/1d/2d>                          # 1d объект должен иметь размер строки.
<1/2d_arr> = <2d>[<2d/1d_bools>]                        # 1d_bools должен иметь размер столбца.
```

- **`':'` возвращает срез всех индексов измерения. Пропущенные измерения по умолчанию равны `':'`.**
- **Шестая строка не сработает, если используется кортеж, так как Python преобразует `'obj[i, j]'` в `'obj[(i, j)]'`!**
- **Индексация с использованием среза и одномерного массива работает так же, как при использовании двух срезов (строки 4, 6, 7).**
- **`'ix_([1, 2], [3, 4])'` вернет `'[[1], [2]]'` и `'[[3, 4]]'`. Из-за правил расширения это то же самое, что и использование `'[[1, 1], [2, 2]]'` и `'[[3, 4], [3, 4]]'`.**
- **Любое значение, которое может быть приведено к индексируемой форме, можно присвоить в выборку.**

### Расширение (Broadcasting)

**Набор правил, по которым функции NumPy работают с массивами разных форм.**

```python
left  = [ 0.1 ,  0.6 ,  0.8 ]                           # Shape: (3,)
right = [[0.1], [0.6], [0.8]]                           # Shape: (3, 1)
```

#### 1. Если формы массивов отличаются по длине, то меньшая форма дополняется единицами:

```python
left  = [[0.1 ,  0.6 ,  0.8]]                           # Shape: (1, 3) <- !
right = [[0.1], [0.6], [0.8]]                           # Shape: (3, 1)
```

#### 2. Если какие-либо размеры отличаются, то те, у которых размер 1, расширяются, повторяя элементы:

```python
left  = [[0.1,  0.6,  0.8],                             # Shape: (3, 3) <- !
         [0.1,  0.6,  0.8],
         [0.1,  0.6,  0.8]]

right = [[0.1,  0.1,  0.1],                             # Shape: (3, 3) <- !
         [0.6,  0.6,  0.6],
         [0.8,  0.8,  0.8]]
```

### Пример

#### Для каждой точки возвращает индекс ближайшей точки (`[0.1, 0.6, 0.8] => [1, 2, 1]`):

```python
>>> points = np.array([0.1, 0.6, 0.8])
[ 0.1,  0.6,  0.8 ]
>>> wrapped_points = points.reshape(3, 1)
[[0.1], [0.6], [0.8]]
>>> distances = points - wrapped_points
[[ 0. ,  0.5,  0.7],
 [-0.5,  0. ,  0.2],
 [-0.7, -0.2,  0. ]]
>>> distances = np.abs(distances)
[[ 0. ,  0.5,  0.7],
 [ 0.5,  0. ,  0.2],
 [ 0.7,  0.2,  0. ]]
>>> distances[range(3), range(3)] = np.inf
[[ inf,  0.5,  0.7],
 [ 0.5,  inf,  0.2],
 [ 0.7,  0.2,  inf]]
>>> distances.argmin(1)
[1, 2, 1]
```
## **Изображения**

**Pillow** — это библиотека для обработки изображений в Python. Она предоставляет множество инструментов для работы с изображениями, таких как их создание, открытие, изменение, сохранение и фильтрация. Pillow является улучшенной версией старой библиотеки **PIL (Python Imaging Library)**

```python
# $ pip3 install pillow
from PIL import Image
```

```python
<Image> = Image.new('<mode>', (width, height))  # Создает новое изображение. Также `color=<int/tuple>`.
<Image> = Image.open(<path>)                    # Определяет формат на основе содержимого файла.
<Image> = <Image>.convert('<mode>')             # Преобразует изображение в новый режим (см. Режимы).
<Image>.save(<path>)                            # Определяет формат на основе расширения (PNG/JPG…).
<Image>.show()                                  # Отображает изображение в стандартном приложении.
```

```python
<int/tup> = <Image>.getpixel((x, y))            # Возвращает значение пикселя (его цвет).
<ImgCore> = <Image>.getdata()                   # Возвращает сплющенное представление значений пикселей.
<Image>.putpixel((x, y), <int/tuple>)           # Обновляет значение пикселя. Ограничивает переданные int/s.
<Image>.putdata(<list/ImgCore>)                 # Обновляет пиксели копией последовательности.
<Image>.paste(<Image>, (x, y))                  # Рисует переданное изображение в указанной позиции.
```

```python
<Image> = <Image>.filter(<Filter>)              # Используйте ImageFilter.<name>(<args>) для фильтров.
<Image> = <Enhance>.enhance(<float>)            # Используйте ImageEnhance.<name>(<Image>) для улучшения.
```

```python
<array> = np.array(<Image>)                     # Создает двумерный/трехмерный массив NumPy из изображения.
<Image> = Image.fromarray(np.uint8(<array>))    # Используйте <array>.clip(0, 255), чтобы ограничить значения.
```

### Режимы

- **`'L'` - Светлотность (изображение в оттенках серого). Каждый пиксель — целое число от 0 до 255.**
- **`'RGB'` - Красный, зеленый, синий (изображение в истинных цветах). Каждый пиксель — кортеж из трех целых чисел.**
- **`'RGBA'` - RGB с альфа-каналом. Низкий альфа-канал (т.е. четвертое число) делает пиксели более прозрачными.**
- **`'HSV'` - Оттенок, насыщенность, яркость. Три целых числа, представляющих цвет в цветовой модели HSV.**

### Примеры

#### Создание PNG-изображения с градиентом радуги:

```python
WIDTH, HEIGHT = 100, 100
n_pixels = WIDTH * HEIGHT
hues = (255 * i/n_pixels for i in range(n_pixels))
img = Image.new('HSV', (WIDTH, HEIGHT))
img.putdata([(int(h), 255, 255) for h in hues])
img.convert('RGB').save('test.png')
```

#### Добавление шума к PNG-изображению и его отображение:

```python
from random import randint
add_noise = lambda value: max(0, min(255, value + randint(-20, 20)))
img = Image.open('test.png').convert('HSV')
img.putdata([(add_noise(h), s, v) for h, s, v in img.getdata()])
img.show()
```

### Рисование на изображении

```python
from PIL import ImageDraw
<Draw> = ImageDraw.Draw(<Image>)                # Объект для добавления 2D-графики на изображение.
<Draw>.point((x, y))                            # Рисует точку. Преобразует float в int.
<Draw>.line((x1, y1, x2, y2 [, ...]))           # Для сглаживания используйте изменение размера изображения.
<Draw>.arc((x1, y1, x2, y2), deg1, deg2)        # Рисует дугу по часовой стрелке. Также pieslice().
<Draw>.rectangle((x1, y1, x2, y2))              # Также rounded_rectangle(), regular_polygon().
<Draw>.polygon((x1, y1, x2, y2, ...))           # Последняя точка соединяется с первой.
<Draw>.ellipse((x1, y1, x2, y2))                # Для поворота используйте rotate() и paste() изображения.
<Draw>.text((x, y), <str>, font=<Font>)         # `<Font> = ImageFont.truetype(<path>, size)`.
```

- **Используйте `'fill=<color>'` для установки основного цвета.**
- **Используйте `'width=<int>'` для установки ширины линий или контуров.**
- **Используйте `'outline=<color>'` для установки цвета контуров.**
- **Цвет может быть целым числом, кортежем, строкой в формате `'#rrggbb[aa]'` или именем цвета.**
Animation
---------
#### Creates a GIF of a bouncing ball:
```python
# $ pip3 install imageio
from PIL import Image, ImageDraw
import imageio

WIDTH, HEIGHT, R = 126, 126, 10
frames = []
for velocity in range(1, 16):
    y = sum(range(velocity))
    frame = Image.new('L', (WIDTH, HEIGHT))
    draw = ImageDraw.Draw(frame)
    draw.ellipse((WIDTH/2-R, y, WIDTH/2+R, y+R*2), fill='white')
    frames.append(frame)
frames += reversed(frames[1:-1])
imageio.mimsave('test.gif', frames, duration=0.03)
```


## Аудио
-----
### Операции с WAV-файлами

1. **Чтение WAV-файлов**:
    
    ```python
    import wave
    ```
    
    - Открытие WAV файла для чтения:
        
        ```python
        <Wave> = wave.open('<path>')
        ```
        
    - Получение параметров файла:
        - Частота дискретизации:
            
            ```python
            <int> = <Wave>.getframerate()
            ```
            
        - Количество каналов (1 для моно, 2 для стерео):
            
            ```python
            <int> = <Wave>.getnchannels()
            ```
            
        - Ширина сэмпла (в байтах):
            
            ```python
            <int> = <Wave>.getsampwidth()
            ```
            
        - Возвращение всех параметров:
            
            ```python
            <tuple> = <Wave>.getparams()
            ```
            
        - Чтение фреймов:
            
            ```python
            <bytes> = <Wave>.readframes(nframes)
            ```
            
2. **Запись WAV-файлов**: Для записи используется следующий код:
    
    ```python
    <Wave> = wave.open('<path>', 'wb')
    <Wave>.setframerate(<int>)            # Установка частоты дискретизации (например, 44100 для CD)
    <Wave>.setnchannels(<int>)            # Установка числа каналов (1 для моно, 2 для стерео)
    <Wave>.setsampwidth(<int>)            # Установка ширины сэмпла (например, 2 для CD)
    <Wave>.setparams(<tuple>)             # Установка всех параметров
    <Wave>.writeframes(<bytes>)           # Запись фреймов в файл
    ```
    
3. **Описание байтовых объектов**:
    
    - Объект `bytes` содержит последовательность фреймов, каждый из которых состоит из одного или нескольких сэмплов.
    - В стереофоническом сигнале первый сэмпл фрейма принадлежит левому каналу.
    - Каждый сэмпл состоит из одного или нескольких байтов, которые, преобразованные в целое число, указывают на отклонение мембраны динамика в определенный момент времени.
4. **Типы данных для сэмплов**: В зависимости от ширины сэмпла, значения могут быть:
	
| sampwidth | min      | zero | max     |
| --------- | -------- | ---- | ------- |
| 1         | 0        | 128  | 255     |
| 2         | -32768   | 0    | 32767   |
| 3         | -8388608 | 0    | 8388607 |
	
5. **Чтение сэмплов как чисел с плавающей точкой**: Функция для чтения WAV-файла с преобразованием сэмплов в числа с плавающей точкой:
    
    ```python
    def read_wav_file(filename):
        def get_int(bytes_obj):
            an_int = int.from_bytes(bytes_obj, 'little', signed=(p.sampwidth != 1))
            return an_int - 128 * (p.sampwidth == 1)
        with wave.open(filename) as file:
            p = file.getparams()
            frames = file.readframes(-1)
        bytes_samples = (frames[i : i + p.sampwidth] for i in range(0, len(frames), p.sampwidth))
        return [get_int(b) / pow(2, (p.sampwidth * 8) - 1) for b in bytes_samples], p
    ```
    
6. **Запись сэмплов с плавающей точкой в WAV-файл**: Функция для записи сэмплов с плавающей точкой в WAV-файл:
    
    ```python
    def write_to_wav_file(filename, samples_f, p=None, nchannels=1, sampwidth=2, framerate=44100):
        def get_bytes(a_float):
            a_float = max(-1, min(1 - 2e-16, a_float))
            a_float += p.sampwidth == 1
            a_float *= pow(2, (p.sampwidth * 8) - 1)
            return int(a_float).to_bytes(p.sampwidth, 'little', signed=(p.sampwidth != 1))
        if p is None:
            p = wave._wave_params(nchannels, sampwidth, framerate, 0, 'NONE', 'not compressed')
        with wave.open(filename, 'wb') as file:
            file.setparams(p)
            file.writeframes(b''.join(get_bytes(f) for f in samples_f))
    ```
    

### Примеры:

1. **Запись синусоидального сигнала**: Сохранение синусоидального сигнала с частотой 440 Гц в моно WAV-файл:
    
    ```python
    from math import pi, sin
    samples_f = (sin(i * 2 * pi * 440 / 44100) for i in range(100_000))
    write_to_wav_file('test.wav', samples_f)
    ```
    
2. **Добавление шума в WAV-файл**: Добавление случайного шума в WAV-файл:
    
    ```python
    from random import uniform
    samples_f, params = read_wav_file('test.wav')
    samples_f = (f + uniform(-0.05, 0.05) for f in samples_f)
    write_to_wav_file('test.wav', samples_f, params)
    ```
    
3. **Воспроизведение WAV-файла**: Воспроизведение WAV-файла с использованием библиотеки `simpleaudio`:
    
    ```python
    # Установите simpleaudio с помощью pip3 install simpleaudio
    from simpleaudio import play_buffer
    with wave.open('test.wav') as file:
        p = file.getparams()
        frames = file.readframes(-1)
        play_buffer(frames, p.nchannels, p.sampwidth, p.framerate).wait_done()
    ```
    

### Преобразование текста в речь:

Для преобразования текста в речь с помощью библиотеки `pyttsx3`:

```python
# Установите pyttsx3 с помощью pip3 install pyttsx3
import pyttsx3
engine = pyttsx3.init()
engine.say('Sally sells seashells by the seashore.')
engine.runAndWait()
```

## Синтезатор
-----------
Вот пример кода синтезатора для воспроизведения "Popcorn" Гершона Кингсли на Python с использованием библиотеки `simpleaudio`:

```python
# $ pip3 install simpleaudio
import array, itertools as it, math, simpleaudio

F  = 44100  # Частота дискретизации
P1 = '71♩,69♪,,71♩,66♪,,62♩,66♪,,59♩,,,71♩,69♪,,71♩,66♪,,62♩,66♪,,59♩,,,'  # Первая часть мелодии
P2 = '71♩,73♪,,74♩,73♪,,74♪,,71♪,,73♩,71♪,,73♪,,69♪,,71♩,69♪,,71♪,,67♪,,71♩,,,'  # Вторая часть мелодии

# Лямбда-функции
get_pause   = lambda seconds: it.repeat(0, int(seconds * F))  # Пауза длительностью в секунды
sin_f       = lambda i, hz: math.sin(i * 2 * math.pi * hz / F)  # Генератор синусоиды с частотой hz
get_wave    = lambda hz, seconds: (sin_f(i, hz) for i in range(int(seconds * F)))  # Генератор волны на указанное время
get_hz      = lambda note: 440 * 2 ** ((int(note[:2]) - 69) / 12)  # Получить частоту ноты
get_sec     = lambda note: 1/4 if '♩' in note else 1/8  # Длительность ноты (1/4 для ♩, 1/8 для ♪)
get_samples = lambda note: get_wave(get_hz(note), get_sec(note)) if note else get_pause(1/8)  # Получить сэмплы для ноты

# Генерация сэмплов
samples_f   = it.chain.from_iterable(get_samples(n) for n in (P1+P2).split(','))
samples_i   = array.array('h', (int(f * 30000) for f in samples_f))  # Преобразуем сэмплы в массив целых чисел

# Воспроизведение звука
simpleaudio.play_buffer(samples_i, 1, 2, F).wait_done()
```

### Объяснение:

1. **Частота дискретизации (`F`)** — 44100 Гц, стандартная частота для аудио.
2. **Мелодия** представлена строками `P1` и `P2`, где используются ноты с длительностями: `♩` (четвертная нота) и `♪` (восьмушка).
3. Лямбда-функции генерируют синусоиды для каждой ноты и длину для каждой ноты в зависимости от символа `♩` или `♪`.
4. Генератор `get_samples` создает сэмплы звука для каждой ноты, соединяя их в одном потоке.
5. Сэмплы преобразуются в целые числа для передачи в аудиофункцию `play_buffer` из библиотеки `simpleaudio`.

## Pygame

**`Pygame`** — это библиотека Python для разработки 2D-игр и работы с мультимедиа. Она предоставляет инструменты для управления окнами, изображениями, звуками, текстом, событиями и взаимодействием с пользователем.

---

### Основы использования

```python
# Установка:
$ pip3 install pygame

# Пример создания окна и перемещения прямоугольника:
import pygame as pg

pg.init()
screen = pg.display.set_mode((500, 500))  # Создаём окно 500x500
rect = pg.Rect(240, 240, 20, 20)          # Прямоугольник 20x20 в центре
while not pg.event.get(pg.QUIT):          # Цикл, пока не закрыли окно
    deltas = {                            # Словарь смещений по клавишам
        pg.K_UP: (0, -20), pg.K_RIGHT: (20, 0),
        pg.K_DOWN: (0, 20), pg.K_LEFT: (-20, 0)
    }
    for event in pg.event.get(pg.KEYDOWN):  # Обработка нажатий клавиш
        dx, dy = deltas.get(event.key, (0, 0))
        rect = rect.move((dx, dy))
    screen.fill(pg.Color('black'))         # Заливка окна чёрным
    pg.draw.rect(screen, pg.Color('white'), rect)  # Рисуем белый прямоугольник
    pg.display.flip()                      # Обновление экрана
```

---

### Прямоугольники (`Rect`)

**Объект для работы с координатами прямоугольников.**

- Создание:

```python
<Rect> = pg.Rect(x, y, width, height)     # Создаёт прямоугольник
```

- Свойства и методы:

```python
<Rect>.move((dx, dy))                     # Возвращает новый Rect со смещением
<Rect>.collidepoint((x, y))               # Проверяет, содержит ли точку
<Rect>.colliderect(<Rect>)                # Проверяет пересечение с другим Rect
```

---

### Поверхности (`Surface`)

**Для работы с изображениями и отрисовкой.**

- Создание:

```python
<Surf> = pg.display.set_mode((w, h))      # Открывает окно и возвращает его поверхность
<Surf> = pg.Surface((w, h))               # Создаёт RGB поверхность
<Surf> = pg.image.load(<path>)            # Загружает изображение
```

- Рисование:

```python
<Surf>.fill(color)                        # Заливка поверхности цветом
<Surf>.blit(<Surf>, (x, y))               # Рисует одну поверхность на другой
```

---

### Шрифты (`Font`) и текст

```python
<Font> = pg.font.Font(None, size)         # Загружает шрифт. None — системный шрифт
<Surf> = <Font>.render(text, antialias, color)  # Рендер текста на поверхность
```

---

### Звук (`Sound`)

```python
<Sound> = pg.mixer.Sound(<path>)          # Загружает звук (WAV/байты)
<Sound>.play()                            # Воспроизводит звук
```

---

### Пример игры "Марио"

```python
import collections, dataclasses, enum, io, itertools as it, pygame as pg, urllib.request
from random import randint

P = collections.namedtuple('P', 'x y')          # Position
D = enum.Enum('D', 'n e s w')                   # Direction
W, H, MAX_S = 50, 50, P(5, 10)                  # Width, Height, Max speed

def main():
    def get_screen():
        pg.init()
        return pg.display.set_mode((W*16, H*16))
    def get_images():
        url = 'https://gto76.github.io/python-cheatsheet/web/mario_bros.png'
        img = pg.image.load(io.BytesIO(urllib.request.urlopen(url).read()))
        return [img.subsurface(get_rect(x, 0)) for x in range(img.get_width() // 16)]
    def get_mario():
        Mario = dataclasses.make_dataclass('Mario', 'rect spd facing_left frame_cycle'.split())
        return Mario(get_rect(1, 1), P(0, 0), False, it.cycle(range(3)))
    def get_tiles():
        border = [(x, y) for x in range(W) for y in range(H) if x in [0, W-1] or y in [0, H-1]]
        platforms = [(randint(1, W-2), randint(2, H-2)) for _ in range(W*H // 10)]
        return [get_rect(x, y) for x, y in border + platforms]
    def get_rect(x, y):
        return pg.Rect(x*16, y*16, 16, 16)
    run(get_screen(), get_images(), get_mario(), get_tiles())

def run(screen, images, mario, tiles):
    clock = pg.time.Clock()
    pressed = set()
    while not pg.event.get(pg.QUIT) and clock.tick(28):
        keys = {pg.K_UP: D.n, pg.K_RIGHT: D.e, pg.K_DOWN: D.s, pg.K_LEFT: D.w}
        pressed |= {keys.get(e.key) for e in pg.event.get(pg.KEYDOWN)}
        pressed -= {keys.get(e.key) for e in pg.event.get(pg.KEYUP)}
        update_speed(mario, tiles, pressed)
        update_position(mario, tiles)
        draw(screen, images, mario, tiles)

def update_speed(mario, tiles, pressed):
    x, y = mario.spd
    x += 2 * ((D.e in pressed) - (D.w in pressed))
    x += (x < 0) - (x > 0)
    y += 1 if D.s not in get_boundaries(mario.rect, tiles) else (D.n in pressed) * -10
    mario.spd = P(x=max(-MAX_S.x, min(MAX_S.x, x)), y=max(-MAX_S.y, min(MAX_S.y, y)))

def update_position(mario, tiles):
    x, y = mario.rect.topleft
    n_steps = max(abs(s) for s in mario.spd)
    for _ in range(n_steps):
        mario.spd = stop_on_collision(mario.spd, get_boundaries(mario.rect, tiles))
        x, y = x + (mario.spd.x / n_steps), y + (mario.spd.y / n_steps)
        mario.rect.topleft = x, y

def get_boundaries(rect, tiles):
    deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)}
    return {d for d, delta in deltas.items() if rect.move(delta).collidelist(tiles) != -1}

def stop_on_collision(spd, bounds):
    return P(x=0 if (D.w in bounds and spd.x < 0) or (D.e in bounds and spd.x > 0) else spd.x,
             y=0 if (D.n in bounds and spd.y < 0) or (D.s in bounds and spd.y > 0) else spd.y)

def draw(screen, images, mario, tiles):
    screen.fill((85, 168, 255))
    mario.facing_left = mario.spd.x < 0 if mario.spd.x else mario.facing_left
    is_airborne = D.s not in get_boundaries(mario.rect, tiles)
    image_index = 4 if is_airborne else (next(mario.frame_cycle) if mario.spd.x else 6)
    screen.blit(images[image_index + (mario.facing_left * 9)], mario.rect)
    for t in tiles:
        is_border = t.x in [0, (W-1)*16] or t.y in [0, (H-1)*16]
        screen.blit(images[18 if is_border else 19], t)
    pg.display.flip()

if __name__ == '__main__':
    main()
```

Вот переведенный и отформатированный материал на русском языке для использования в шпаргалке:

---

## Pandas

**Библиотека для анализа данных.**  
Примеры использования — см. [[#Plotly]]

```python
# Установка библиотеки
# $ pip3 install pandas matplotlib
import pandas as pd, matplotlib.pyplot as plt
```

---

### Series

**Упорядоченный словарь с именем.**

```python
>>> s = pd.Series([1, 2], index=['x', 'y'], name='a'); s
x    1
y    2
Name: a, dtype: int64
```

#### Создание Series

```python
<S>  = pd.Series(<список>)                    # Индексы создаются на основе индексов списка.
<S>  = pd.Series(<словарь>)                   # Индексы создаются из ключей словаря.
```

#### Доступ к элементам Series

```python
<элемент> = <S>.loc[ключ]                     # Или: <S>.iloc[индекс]
<S>        = <S>.loc[коллекция_ключей]        # Или: <S>.iloc[коллекция_индексов]
<S>        = <S>.loc[ключ_от:ключ_до_включ.]  # Или: <S>.iloc[от_индекса:до_индекса]
```

#### Фильтрация и операции

```python
<элемент> = <S>[ключ/индекс]                 # Или: <S>.<ключ>
<S>       = <S>[<булевые_значения>]          # Фильтрует Series.
<S>       = <S> > <значение/S>               # Возвращает булевый Series.
<S>       = <S> + <значение/S>               # Складывает Series. Несовпадающие индексы получают NaN.
```

#### Работа с несколькими Series

```python
<S> = pd.concat(<коллекция_S>)               # Конкатенирует несколько Series.
<S> = <S>.combine_first(<другой_S>)          # Объединяет значения, отсутствующие в первом.
<S>.update(<другой_S>)                       # Обновляет существующие значения.
```

#### Графики

```python
<S>.plot.line/area/bar/pie/hist()            # Создает график. Используйте plt.show() для отображения.
```

---

### DataFrame

**Таблица с метками строк и столбцов.**

```python
>>> df = pd.DataFrame([[1, 2], [3, 4]], index=['a', 'b'], columns=['x', 'y']); df
   x  y
a  1  2
b  3  4
```

#### Создание DataFrame

```python
<DF> = pd.DataFrame(<список_строк>)          # Строки могут быть списками, словарями или Series.
<DF> = pd.DataFrame(<словарь_столбцов>)      # Столбцы могут быть списками, словарями или Series.
```

#### Доступ к элементам

```python
<элемент> = <DF>.loc[ключ_строки, ключ_столбца]   # Или: <DF>.iloc[индекс_строки, индекс_столбца]
<S/DF>    = <DF>.loc[ключ_строки/коллекция]      # Или: <DF>.iloc[индекс_строки/коллекция]
<S/DF>    = <DF>.loc[:, ключ_столбца/коллекция]  # Или: <DF>.iloc[:, индекс_столбца/коллекция]
<DF>      = <DF>[<Series_булевых_значений>]      # Фильтрует строки.
```

#### Операции и сортировка

```python
<DF> = <DF>.set_index(<ключ_столбца>)            # Устанавливает столбец как индекс.
<DF> = <DF>.sort_index(ascending=True)          # Сортирует строки по индексу.
<DF> = <DF>.sort_values(<ключ_столбца>)         # Сортирует строки по значениям столбца.
```

#### Анализ и статистика

```python
<DF>.describe()                               # Выводит сводную статистику.
<DF>.query('<условие>')                       # Фильтрует строки, например: df.query('x > 1').
```

#### Построение графиков

```python
<DF>.plot.line/area/bar/scatter(x=ключ, …)    # Параметры: y=ключ или ключи столбцов.
plt.show()                                   # Показывает график.
```

---

### GroupBy

**Объект для группировки строк DataFrame.**

```python
<GB> = <DF>.groupby(<ключ_столбца>)           # Группирует строки по значениям столбца.
<DF> = <GB>.apply(<функция>)                  # Применяет функцию к каждой группе.
<DF> = <GB>.filter(<функция>)                 # Удаляет группы, если функция возвращает False.
<Series> = <GB>.size()                        # Размеры групп.
```

---

### Чтение и запись данных

```python
<DF> = pd.read_csv('<путь/URL>')             # Чтение CSV-файла.
<DF> = pd.read_excel('<путь>')               # Чтение Excel-файла (необходим odfpy).
<DF> = pd.read_sql('<запрос>', <соединение>) # SQL-запрос к базе данных.

<DF>.to_csv('<путь>')                        # Сохранение в CSV.
<DF>.to_excel('<путь>')                      # Сохранение в Excel.
```

---

Для детальной информации смотрите [официальную документацию](https://pandas.pydata.org/docs/).

## Plotly

### Установка
```bash
$ pip install plotly
# Для Jupyter Notebook:
$ pip install "notebook>=5.3" "ipywidgets>=7.5"
````

### Импорт

```python
import plotly.graph_objects as go  # Основные графики
import plotly.express as px       # Упрощённый интерфейс
```

---

### Быстрые графики с Plotly Express

#### Линейный график

```python
import pandas as pd

data = pd.DataFrame({'x': [1, 2, 3], 'y': [4, 1, 7]})
fig = px.line(data, x='x', y='y', title="Линейный график")
fig.show()
```

#### Точечный график

```python
fig = px.scatter(data, x='x', y='y', title="Точечный график")
fig.show()
```

#### Гистограмма

```python
fig = px.histogram(data, x='x', title="Гистограмма")
fig.show()
```

#### 3D График

```python
data = pd.DataFrame({'x': [1, 2, 3], 'y': [4, 1, 7], 'z': [10, 20, 30]})
fig = px.scatter_3d(data, x='x', y='y', z='z', title="3D Точечный график")
fig.show()
```

---

### Продвинутые графики с Graph Objects

#### Линейный график

```python
fig = go.Figure()
fig.add_trace(go.Scatter(x=[1, 2, 3], y=[4, 1, 7], mode='lines+markers', name="Линия"))
fig.update_layout(title="Линейный график", xaxis_title="X", yaxis_title="Y")
fig.show()
```

#### Гистограмма

```python
fig = go.Figure()
fig.add_trace(go.Histogram(x=[1, 2, 2, 3, 3, 3], name="Гистограмма"))
fig.update_layout(title="Гистограмма", xaxis_title="Значения", yaxis_title="Частота")
fig.show()
```

#### Столбчатая диаграмма

```python
fig = go.Figure()
fig.add_trace(go.Bar(x=['A', 'B', 'C'], y=[4, 1, 7], name="Столбцы"))
fig.update_layout(title="Столбчатая диаграмма", xaxis_title="Категории", yaxis_title="Значения")
fig.show()
```

#### Круговая диаграмма

```python
fig = go.Figure()
fig.add_trace(go.Pie(labels=['A', 'B', 'C'], values=[4, 1, 7]))
fig.update_layout(title="Круговая диаграмма")
fig.show()
```

---

### Пользовательская настройка

#### Обновление разметки графика

```python
fig.update_layout(
    title="Название графика",
    xaxis_title="Название оси X",
    yaxis_title="Название оси Y",
    template="plotly_dark"  # Встроенные стили: "plotly", "ggplot2", "seaborn" и др.
)
```

#### Добавление аннотаций

```python
fig.add_annotation(x=2, y=4, text="Точка", showarrow=True, arrowhead=2)
```

#### Настройка осей

```python
fig.update_xaxes(showgrid=True, zeroline=False)
fig.update_yaxes(range=[0, 10], showticklabels=True)
```

---

### Сохранение графика

```python
fig.write_html("graph.html")  # Сохранение как HTML
fig.write_image("graph.png")  # Требуется установка kaleido: `pip install -U kaleido`
```

### 3D Графики

#### Поверхностный график

```python
import numpy as np

x = np.linspace(-2, 2, 50)
y = np.linspace(-2, 2, 50)
X, Y = np.meshgrid(x, y)
Z = np.sin(np.sqrt(X**2 + Y**2))

fig = go.Figure(go.Surface(z=Z, x=X, y=Y))
fig.update_layout(title="3D Поверхность", scene=dict(zaxis=dict(range=[-1, 1])))
fig.show()
```

---

### Полезные ресурсы

- [Официальная документация](https://plotly.com/python/)
- [Галерея примеров](https://plotly.com/python/gallery/)
# Приложение

### Cython
**Библиотека, компилирующая Python-код в C для ускорения работы.**

#### Установка и использование:
```bash
# Установить Cython
$ pip3 install cython

# Импортировать и запустить скомпилированный скрипт
import pyximport; pyximport.install()
import <cython_script>
<cython_script>.main()
````

#### Основные моменты:

- **Определения с помощью `cdef` не обязательны, но ускоряют выполнение.**
- **Скрипт необходимо сохранять с расширением `.pyx` для компиляции.**

#### Примеры синтаксиса:

```python
# Определение переменных и функций
cdef <ctype> <var_name> = <obj>
cdef <ctype>[n_elements] <var_name> = [<el_1>, <el_2>, ...]
cdef <ctype/void> <func_name>(<ctype> <arg_name>): ...
```

```python
# Определение класса
cdef class <class_name>:
    cdef public <ctype> <attr_name>
    def __init__(self, <ctype> <arg_name>):
        self.<attr_name> = <arg_name>
```

---

### Виртуальные окружения

**Система установки библиотек в директорию проекта.**

#### Основные команды:

```bash
$ python3 -m venv NAME      # Создать виртуальное окружение в текущей директории.
$ source NAME/bin/activate  # Активировать окружение. На Windows: `NAME\Scripts\activate`.
$ pip3 install LIBRARY      # Установить библиотеку в активное окружение.
$ python3 FILE              # Запустить скрипт в активном окружении. Альтернатива: `./FILE`.
$ deactivate                # Деактивировать виртуальное окружение.
```

---

### Шаблон базового скрипта

**Запуск скрипта: `$ python3 FILE` или `$ chmod u+x FILE; ./FILE`.  
Для отладки при необработанных исключениях: `$ python3 -m pdb -cc FILE`.**

```python
#!/usr/bin/env python3
#
# Использование: .py
#

from sys import argv, exit
from collections import defaultdict, namedtuple
from dataclasses import make_dataclass
from enum import Enum
import functools as ft, itertools as it, operator as op, re


def main():
    pass


###
##  УТИЛИТЫ
#

def read_file(filename):
    with open(filename, encoding='utf-8') as file:
        return file.readlines()


if __name__ == '__main__':
    main()
```
